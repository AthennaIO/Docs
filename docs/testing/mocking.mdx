---
title: Mocking
sidebar_position: 4
description: Understand how to mock dependencies and functions in Athenna.
---

# Mocking

Understand how to mock dependencies and functions in Athenna.

## Introduction

When testing Athenna applications, you may wish to "mock" 
certain aspects of your application, so they are not actually
executed during a given test. For example, when testing a 
controller that calls a service, you may wish to mock the 
service, so they are not actually executed during the test.
This allows you to only test the controller's HTTP response 
without worrying about the execution of the service since 
the service can be tested in their own test case.

## Mocking API

### The `Mock::when()` method

This method is responsible for mocking the return
value of a given object method:

```typescript
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  public object = {
    hello: () => undefined
  }

  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockAnObjectMethod({ assert }: Context) {
    Mock.when(this.object, 'hello').return('hello world')

    assert.equal(this.object.hello(), 'hello world')
  }
}
```

You can also use this method to throw an error when the
given method is called:

```typescript
@Test()
public async shouldBeAbleToMockAnObjectMethod({ assert }: Context) {
  Mock.when(this.object, 'hello').throw(new Error('hello world'))

  assert.throw(() => this.object.hello(), 'hello world')
}
```

For promises, you can use the `resolve()` or `reject()` methods:

```typescript
@Test()
public async mockAnObjectMethod({ assert }: Context) {
  // Resolving a promise
  Mock.when(this.object, 'hello').resolve('hello world')
  assert.equal(await this.object.hello(), 'hello world')

  // Rejecting a promise
  Mock.when(this.object, 'hello').reject(new Error('hello world'))
  await assert.rejects(() => this.object.hello(), 'hello world')
}
```

If you don't have access to the method you want to mock, you can
save the return of `Mock::when()` method and use it to make your
assertions:

```typescript
@Test()
public async mockAnObjectMethod({ assert }: Context) {
  const helloMock = Mock.when(this.object, 'hello').resolve('hello world')

  await this.someMethodThatCallsHelloMethod()

  assert.isTrue(helloMock.called)
}
```

#### Mocking a class method

There are two ways to mock a class method. The first one is
mocking the class instance directly:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  public apiHelper = new ApiHelper()

  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockAClassMethod({ assert }: Context) {
    Mock.when(this.apiHelper, 'findOne').return({ fake: true })

    assert.deepEqual(this.apiHelper.findOne(), { fake: true })
  }
}
```

With this approach, you can only mock the method for the current
instance. If another instance of `ApiHelper` is created, that
one will not be mocked.

To mock a class method for all instances of a given class, you
need to mock the class `prototype`:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockAClassMethod({ assert }: Context) {
    Mock.when(ApiHelper.prototype, 'findOne').return({ fake: true })

    assert.deepEqual(new ApiHelper().findOne(), { fake: true })
  }
}
```

:::caution

Never forget to restore all mocks after each test case. If you don't
restore it, the mock will be kept in memory and will affect your other
tests. Test cases should be isolated from each other, so always try to
create your mocks inside your test cases to avoid problems when your
application gets bigger.

:::

### The `Mock::spy()` method

This method is responsible for spying on a given object method.
Different from `Mock::when()`, this method will not change the
behavior of the method, it will only spy it and allow you to verify
if the given method was called, how many times, and with which params:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async spyAClassMethod({ assert }: Context) {
    Mock.spy(ApiHelper.prototype, 'findOne')

    const apiHelper = new ApiHelper()

    apiHelper.findOne()

    assert.calledOnce(apiHelper.findOne)
  }
}
```

Just like `Mock::when()`, if you don't have access to the method
you want to spy, you can save the return of `Mock::spy()` method
and use it to make your assertions:

```typescript
@Test()
public async spyAClassMethod({ assert }: Context) {
  const findOneSpy = Mock.spy(ApiHelper.prototype, 'findOne')

  await this.someMethodThatCallsApiHelperFindOne()

  assert.calledOnce(findOneSpy)
}
```

:::tip

For more assertions like `assert.calledOnce()` method, check the
[assertion in mocks](/docs/testing/mocking#assertion-in-mocks)
documentation section.

:::

Since `Mock::spy()` does not change the behavior of the method,
but only spies it, you can use it to spy all the methods of a
given object:

```typescript
@Test()
public async spyAnEntireClass({ assert }: Context) {
  Mock.spy(ApiHelper.prototype)

  const apiHelper = new ApiHelper()

  apiHelper.findOne()

  assert.calledOnce(apiHelper.findOne)
}
```

### The `Mock::fake()` method

This method is responsible for creating a fake object that
you can in parallel with `Mock::when()` method:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockReturnOfClassMethod({ assert }: Context) {
    Mock.when(ApiHelper.prototype, 'findOne').return({
      hello: Mock.fake()
    })

    const apiHelper = new ApiHelper()

    const result = apiHelper.findOne()

    result.hello()

    assert.calledOnce(result.hello)
    assert.calledOnce(apiHelper.findOne)
  }
}
```

## Mocking services

Mocking a service is the same process of mocking a simple class
using the `prototype` property:

```typescript
import { AppService } from '#app/services/AppService'
import { Test, Mock, type Context, AfterEach } from '@athenna/test'

export default class MockTest {
  @AfterEach()
  public afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockServiceMethod({ assert }: Context) {
    Mock.when(AppService.prototype, 'findOne').return({ fake: true }) üëà

    assert.deepEqual(new AppService().findOne(), { fake: true })
  }
}
```

### Replacing the entire service

Sometimes you may want to have more control over the service
instance; for this scenario, we recommend you to create a new instance
of the service within your test class, registering it in the service
container and then mocking the method you want in each test case:

```typescript
import { AppService } from '#app/services/AppService'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'
import { Test, type Context, BeforeAll, Mock, AfterEach } from '@athenna/test'

export default class AppControllerTest extends BaseHttpTest {
  public appService = new AppService()

  @BeforeAll()
  public async beforeAll() {
    ioc.instance('App/Services/AppService', this.appService) üëà
  }

  @AfterEach()
  public async afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockServiceMethod({ assert, request }: Context) {
    Mock.when(this.appService, 'findOne').return({ fake: true }) üëà

    const response = await request.get('/api/v1')

    response.assertStatusCode(200)
    response.assertBodyContains({ fake: true })
    assert.calledOnce(this.appService.findOne)
  }
}
```

:::warning

Keep in mind that if you change your service alias in the
`@Service()` annotation, you will also need to use the same
value in the `ioc.instance()` method.

For more information, check the [`@Service()`](/docs/architecture-concepts/service-container#the-service-annotation)
annotation documentation section.

:::

With `ioc.instance()` method, you can also create an entire different
implementation of your service that will be used only for testing:

```typescript title="Path.fixtures('services/FakeAppService.ts')"
import { AppServiceInterface } from '#app/interfaces/AppServiceInterface'

export class FakeAppService implements AppServiceInterface {
  public findOne() {
    return { fake: true }
  }
}
```

And now let's use it in our test class:

```typescript
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'
import { FakeAppService } from '#tests/fixtures/services/FakeAppService'
import { Test, type Context, BeforeAll, Mock, AfterEach } from '@athenna/test'

export default class AppControllerTest extends BaseHttpTest {
  @BeforeAll()
  public async beforeAll() {
    ioc.instance('App/Services/AppService', new FakeAppService()) üëà
  }

  @AfterEach()
  public async afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockServiceMethod({ request }: Context) {
    const response = await request.get('/api/v1')

    response.assertStatusCode(200)
    response.assertBodyContains({ fake: true }) üëà
  }
}
```

:::tip

Taste the power of dependency injection! üöÄüßô‚Äç‚ôÇÔ∏è

:::

## Mocking facades

When testing, you may often want to mock a call to
an Athenna facade that occurs in your code logic.
For example, consider the following controller action:

```typescript
import { Mail } from '@athenna/mail'
import { Controller, type Context } from '@athenna/http'

@Controller()
export class UserController {
  public async store({ response }: Context) {
    const user = {
      name: 'Antoine Du Hamel',
      email: 'duhamelantoine1995@gmail.com'
    }

    await Mail.from('lenon@athenna.io')
        .to(user.email)
        .subject(`Welcome ${user.name} to Athenna!`)
        .html('<h1>Welcome to Athenna!</h1>')
        .send()

    return response.status(200).send(user)
  }
}
```

We can mock the call to the `Mail` facade by using the
`when()` method, check the example:

```typescript
import { Mail } from '@athenna/mail'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'
import { Test, type Context, Mock, AfterEach } from '@athenna/test'

export default class AppControllerTest extends BaseHttpTest {
  @AfterEach()
  public async afterEach() {
    Mock.restoreAll()
  }

  @Test()
  public async mockMailSendMethod({ assert, request }: Context) {
    Mail.when('send').resolve(undefined) üëà

    const response = await request.post('/api/v1/users')

    assert.calledOnce(Mail.send) üëà
    response.assertStatusCode(200)
    response.assertBodyContains([
        // ...
    ])
  }
}
```

### Facade stubs

Coming soon...

### Facade spies

Coming soon...

## Assertions in mocks

Coming soon...

## Mocking commands

Coming soon...
