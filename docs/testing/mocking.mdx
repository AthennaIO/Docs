---
title: Mocking
sidebar_position: 5
description: Understand how to mock dependencies and functions in Athenna.
---

# Mocking

Understand how to mock dependencies and functions in Athenna.

## Introduction

When testing Athenna applications, you may wish to "mock" 
certain aspects of your application, so they are not actually
executed during a given test. For example, when testing a 
controller that calls a service, you may wish to mock the 
service, so they are not actually executed during the test.
This allows you to only test the controller's HTTP response 
without worrying about the execution of the service since 
the service can be tested in their own test case.

This API uses [sinon](https://sinonjs.org/) library under
the hood to integrate with the Athenna ecosystem. If you need
to create more complex mocks, we recommend you to check their
documentation.

## Mocking objects

The most convenient way to mock an object and change
it behavior is by using the `Mock::when()` method:

```typescript
import { Test, Mock, type Context } from '@athenna/test'

export default class MockTest {
  public object = {
    foo: () => undefined
  }

  @Test()
  public async mockAnObjectMethod({ assert }: Context) {
    Mock.when(this.object, 'foo').return('bar') 👈

    assert.equal(this.object.foo(), 'bar')
  }
}
```

:::tip

The `Mock::when()` method is a shorthand for `Mock::stub()`.
If you want to learn more about stubs and their API, check
[the stub documentation](https://sinonjs.org/releases/latest/stubs/)
from sinon.

:::

You can also use this method to throw an error when the
given method is called:

```typescript
@Test()
public async mockAnObjectMethod({ assert }: Context) {
  Mock.when(this.object, 'foo').throw(new Error()) 👈

  assert.throw(() => this.object.foo(), Error)
}
```

For promises, you can use the `resolve()` or `reject()` methods:

```typescript
@Test()
public async mockAnObjectMethod({ assert }: Context) {
  // Resolving a promise
  Mock.when(this.object, 'foo').resolve('bar')
  assert.equal(await this.object.bar(), 'bar')

  // Rejecting a promise
  Mock.when(this.object, 'foo').reject(new Error())
  await assert.rejects(() => this.object.foo(), Error)
}
```

If you don't have access to the method you are mocking, you can
save the return of `Mock::when()` method and use it to make your
assertions:

```typescript
@Test()
public async mockAnObjectMethod({ assert }: Context) {
  const fooMock = Mock.when(this.object, 'foo').resolve('bar')

  await this.someMethodThatCallsFooMethod()

  assert.isTrue(fooMock.called)
}
```

To deal with more complex objects while using
`Mock::when()`, you can use the `Mock::fake()`
method that creates a fake method that you can
replace by the original one:

```typescript
import { Test, Mock, type Context } from '@athenna/test'

export default class MockTest {
  public object = {
    foo: () => ({ bar: () => undefined })
  }

  @Test()
  public async fakeAnObjectMethod({ assert }: Context) {
    const barFake = Mock.fake()
    Mock.when(this.object, 'foo').return({ bar: barFake }) 👈

    this.object.foo().bar()

    assert.calledOnce(barFake)
  }
}
```

:::tip

For more assertions like `assert.calledOnce()` method, check the
[assertion in mocks](/docs/testing/mocking#assertion-in-mocks)
documentation section.

:::

### Restoring mocks

When you mock a method, you are changing its behavior, so
is important to restore the default behavior of the method
and also reset the mock history after your test finishes.

To do so you can use the `Mock::restore()` method within
`@AfterEach()` hook:

```typescript
import { Test, Mock, AfterEach, type Context } from '@athenna/test'

export default class MockTest {
  public object = {
    foo: () => undefined
  }

  @AfterEach()
  public afterEach() {
    Mock.restore(this.object.foo) 👈
  }

  @Test()
  public async mockAnObjectMethod({ assert }: Context) {
    Mock.when(this.object, 'foo').return('bar')

    assert.equal(this.object.foo(), 'bar')
  }
}
```

Restoring each mock individually can be a tedious task, so
to be more convenient for you, use the `Mock::restoreAll()`
method to restore all everything that has been mocked using
`Mock` class to default:

```typescript
@AfterEach()
public afterEach() {
 Mock.restoreAll()
}
```

### Spying objects

Sometimes you might need to only spy a given method
without changing its behavior. For this scenario, you
can use the `Mock::spy()` method:

```typescript
import { Test, Mock, type Context } from '@athenna/test'

export default class MockTest {
  public object = {
    foo: () => 'bar'
  }

  @Test()
  public async spyAnObjectMethod({ assert }: Context) {
    const spy = Mock.spy(this.object, 'foo') 👈

    assert.equal(this.object.foo(), 'bar')
    assert.isTrue(spy.called) 👈
  }
}
```

You can also spy an entire object using `Mock::spy()`:

```typescript
@Test()
public async spyAnObjectMethod({ assert }: Context) {
  Mock.spy(this.object) 👈

  assert.equal(this.object.foo(), 'bar')
  assert.isTrue(this.object.foo.called) 👈
}
```

Just like `Mock::when()`, if you don't have access to the method
you want to spy, you can save the return of `Mock::spy()` method
and use it to make your assertions:

```typescript
@Test()
public async spyAnObjectMethod({ assert }: Context) {
  Mock.spy(this.object) 👈

  await this.someMethodThatCallsObjectFoo()

  assert.calledOnce(this.object.foo) 👈
}
```

## Mocking classes

Mocking classes is the same of mocking objects. But you need
to be aware when you are mocking a class instance or all instances
of it (`prototype`).

Let's see how to mock a single class instance:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context  } from '@athenna/test'

export default class MockTest {
  public apiHelper = new ApiHelper()

  @Test()
  public async mockAClassMethod({ assert }: Context) {
    Mock.when(this.apiHelper, 'findOne').return({ fake: true })

    assert.deepEqual(this.apiHelper.findOne(), { fake: true })
  }
}
```

As mentioned before, with this approach, you can only mock
the method for the current instance. If another instance of
`ApiHelper` is created, that one will not be mocked.

To mock a class method for all instances of a given class, you
need to mock the class `prototype`:

```typescript
import { ApiHelper } from '#app/helpers/ApiHelper'
import { Test, Mock, type Context } from '@athenna/test'

export default class MockTest {
  @Test()
  public async mockAClassMethod({ assert }: Context) {
    Mock.when(ApiHelper.prototype, 'findOne').return({ fake: true })

    assert.deepEqual(new ApiHelper().findOne(), { fake: true })
  }
}
```

### Mocking services

Since the default registration type of services is [transient](/docs/architecture-concepts/service-container#binding-transients),
mocking a service from the [service container](/docs/architecture-concepts/service-container)
is the same process of mocking a simple class
using the `prototype` property:

```typescript
import { AppService } from '#app/services/AppService'
import { Test, Mock, type Context } from '@athenna/test'

export default class MockTest {
  @Test()
  public async mockServiceMethod({ assert }: Context) {
    Mock.when(AppService.prototype, 'findOne').return({ fake: true }) 👈

    assert.deepEqual(new AppService().findOne(), { fake: true })
  }
}
```

:::tip

If your service is registered as a [singleton](/docs/architecture-concepts/service-container#binding-singletons)
check the [inversion of control](/docs/architecture-concepts/service-container#inversion-of-control)
documentation section.

:::

### Inversion of control

Sometimes you may want to have more control over the service
instance; for this scenario, we recommend you to create a new instance
of the service within your test class, registering it in the service
container and then mocking the method you want in each test case:

```typescript
import { AppService } from '#app/services/AppService'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'
import { Test, type Context, BeforeAll, Mock } from '@athenna/test'

export default class AppControllerTest extends BaseHttpTest {
  public appService = new AppService()

  @BeforeAll()
  public async beforeAll() {
    ioc.instance('App/Services/AppService', this.appService) 👈
  }

  @Test()
  public async mockServiceMethod({ assert, request }: Context) {
    Mock.when(this.appService, 'findOne').return({ fake: true }) 👈

    const response = await request.get('/api/v1')

    response.assertStatusCode(200)
    response.assertBodyContains({ fake: true })
    assert.calledOnce(this.appService.findOne) 👈
  }
}
```

:::warning

Keep in mind that if you change your service alias in the
`@Service()` annotation, you will also need to use the same
value in the `ioc.instance()` method.

For more information, check the [`@Service()`](/docs/architecture-concepts/service-container#the-service-annotation)
annotation documentation section.

:::

With `ioc.instance()` method, you can also create an entire different
implementation of your service that will be used only for testing:

```typescript title="Path.fixtures('services/FakeAppService.ts')"
import { AppServiceInterface } from '#app/interfaces/AppServiceInterface'

export class FakeAppService implements AppServiceInterface {
  public findOne() {
    return { fake: true }
  }
}
```

And now let's use it in our test class:

```typescript
import { Test, BeforeAll, type Context } from '@athenna/test'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'
import { FakeAppService } from '#tests/fixtures/services/FakeAppService'

export default class AppControllerTest extends BaseHttpTest {
  @BeforeAll()
  public async beforeAll() {
    ioc.instance('App/Services/AppService', new FakeAppService()) 👈
  }

  @Test()
  public async mockServiceMethod({ request }: Context) {
    const response = await request.get('/api/v1')

    response.assertStatusCode(200)
    response.assertBodyContains({ fake: true }) 👈
  }
}
```

:::tip

Taste the power of dependency injection! 🚀🧙‍♂️

:::

## Mocking facades

When testing, you may often want to mock a call to
an Athenna facade that occurs in your code logic.
For example, consider the following controller action:

```typescript
import { Mail } from '@athenna/mail'
import { Controller, type Context } from '@athenna/http'

@Controller()
export class UserController {
  public async store({ response }: Context) {
    const user = {
      name: 'Antoine Du Hamel',
      email: 'duhamelantoine1995@gmail.com'
    }

    await Mail.from('lenon@athenna.io')
        .to(user.email)
        .subject(`Welcome ${user.name} to Athenna!`)
        .html('<h1>Welcome to Athenna!</h1>')
        .send()

    return response.status(200).send(user)
  }
}
```

We can mock the call to the `Mail` facade by using the
`when()` method, check the example:

```typescript
import { Mail } from '@athenna/mail'
import { Test, type Context } from '@athenna/test'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'

export default class AppControllerTest extends BaseHttpTest {
  @Test()
  public async mockMailSendMethod({ assert, request }: Context) {
    Mail.when('send').resolve(undefined) 👈

    const response = await request.post('/api/v1/users')

    assert.calledOnce(Mail.send) 👈
    response.assertStatusCode(200)
    response.assertBodyContains([
        // ...
    ])
  }
}
```

### Restoring facades

To restore a mocked facade to it default behavior, you
can use the `restore()` method:

```typescript
@AfterEach()
public afterEach() {
  Mail.restore()
}
```

:::warning

When mocking facades, calling `Mock::restoreAll()` method
will restore the facade to its default behavior, but it
will leave the facade using the same instance for all calls. IOW,
the facade is converted to a [singleton](/docs/architecture-concepts/service-container#binding-singleton).

This could lead to unexpected behavior in your tests, so it is recommended
to restore each facade individually:

```typescript
@AfterEach()
public afterEach() {
  Mail.restore()
  Mock.restoreAll()
}
```

:::

### Spying facades

If you would like to spy on a facade, you may call
the `spy()` method on the corresponding facade:

```typescript
import { Mail } from '@athenna/mail'
import { Test, type Context } from '@athenna/test'
import { BaseHttpTest } from '@athenna/core/testing/BaseHttpTest'

export default class AppControllerTest extends BaseHttpTest {
  @Test()
  public async spyMailSendMethod({ assert, request }: Context) {
    Mail.spy('send') 👈

    const response = await request.post('/api/v1/users')

    assert.calledOnce(Mail.send) 👈
    response.assertStatusCode(200)
    response.assertBodyContains([
        // ...
    ])
  }
}
```

:::note

Remember that the code above will effectively try to send
the email since spies does not change the behavior of the
method.

:::

## Assertions in mocks

Athenna's `assert` helper provides a variety of extended
assertion methods that you may utilize when testing your
mocks:

- [`assert.called()`](/docs/mocking/assertions-in-mocks#assertcalled)
- [`assert.calledOnce()`](/docs/mocking/assertions-in-mocks#assertcalledonce)
- [`assert.calledTimes()`](/docs/mocking/assertions-in-mocks#assertcalledtimes)
- [`assert.calledWith()`](/docs/mocking/assertions-in-mocks#assertcalledwith)
- [`assert.calledOnceWith()`](/docs/mocking/assertions-in-mocks#assertcalledoncewith)
- [`assert.calledTimesWith()`](/docs/mocking/assertions-in-mocks#assertcalledtimeswith)
- [`assert.calledWithMatch()`](/docs/mocking/assertions-in-mocks#assertcalledwithmatch)
- [`assert.calledBefore()`](/docs/mocking/assertions-in-mocks#assertcalledbefore)
- [`assert.calledAfter()`](/docs/mocking/assertions-in-mocks#assertcalledafter)

#### `assert.called()`

Assert the mock was called at least once:

```typescript
assert.called(this.object.foo)
assert.notCalled(this.object.foo)
```

#### `assert.calledOnce()`

Assert the mock was called only once:

```typescript
assert.calledOnce(this.object.foo)
assert.notCalledOnce(this.object.foo)
```

#### `assert.calledTimes()`

Assert the mock was called the given number of times:

```typescript
assert.calledTimes(this.object.foo, 1)
assert.notCalledTimes(this.object.foo, 1)
```

#### `assert.calledWith()`

Assert the mock was called with the given arguments:

```typescript
assert.calledWith(this.object.foo, 'bar')
assert.notCalledWith(this.object.foo, 'bar')
```

#### `assert.calledOnceWith()`

Assert the mock was called only once with the given arguments:

```typescript
assert.calledOnceWith(this.object.foo, 'bar')
assert.notCalledOnceWith(this.object.foo, 'bar')
```

#### `assert.calledTimesWith()`

Assert the mock was called the given times with the given arguments:

```typescript
assert.calledTimesWith(this.object.foo, 1, 'bar')
assert.notCalledTimesWith(this.object.foo, 1, 'bar')
```

#### `assert.calledWithMatch()`

Assert the mock was called with the given arguments
matching some of the given arguments.

```typescript
assert.calledWithMatch(this.object.foo, 'bar')
assert.notCalledWithMatch(this.object.foo, 'bar')
```

:::tip

This is an alias for the following:

```typescript
assert.calledWith(this.object.foo, Mock.match('bar'))
```

:::

#### `assert.calledBefore()`

Assert the mock was called before another mock:

```typescript
assert.calledBefore(this.object.foo, this.object.bar)
assert.notCalledBefore(this.object.foo, this.object.bar)
```

#### `assert.calledAfter()`

Assert the mock was called after another mock:

```typescript
assert.calledAfter(this.object.foo, this.object.bar)
assert.notCalledAfter(this.object.foo, this.object.bar)
```

## Mocking commands

:::note

Before checking how to mock commands, we recommend you
to check the [changing Artisan file path per command
documentation section](/docs/testing/cli-tests#changing-artisan-file-path-per-command)
to understand how you can create an isolated test case
for the command you wish to test.

:::

When testing commands, you may often want to mock some
logic that happens inside the child process that Athenna
creates to run your command.

Let's suppose we have created a command called `greet`
which prompts the user his name to say hy:

```typescript title="Path.commands('Greet.ts')"
import { BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
      return 'greet'
  }

  public async handle(): Promise<void> {
    const name = await this.prompt.input('What is your name?')

    this.logger.info(`Hello ${name}!`)
  }
}
```

If you try to run `greet` command in your tests it will
exceed the timeout since the command will be waiting for
the user input name.

To solve this kind of situation and others, you can create
your own Artisan console that will first mock the `this.prompt.input()`
method and then boot Artisan:

```typescript title="Path.fixtures('consoles/mock-greet-input.ts')"
import { Mock } from '@athenna/test'
import { Ignite } from '@athenna/core'
import { Prompt } from '@athenna/artisan'

const ignite = await new Ignite().load(import.meta.url, { bootLogs: false })

Mock.when(Prompt.prototype, 'input').resolve('Valmir Barbosa')

await ignite.console(process.argv, { displayName: 'Artisan' })
```

Now, we can use this new Artisan console file to run the command
in our test cases:

```typescript
import { Path } from '@athenna/common'
import { Test, type Context } from '@athenna/test'

export default class GreetTest {
  @Test()
  public async testGreet({ command }: Context) {
    const output = await command.run('greet', {
      path: Path.fixtures('consoles/mock-greet-input.ts') 👈
    })

    output.assertLogged('Hello Valmir Barbosa!') ✅
  }
}
```
