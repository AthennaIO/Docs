---
sidebar_position: 2

id: commands
title: Commands
hide_title: true
hide_table_of_contents: true
tags:
- Getting Started
- Architecture Concepts
- The Basics
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">The Basics</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">co</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/the-basics/cli/commands">Commands</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Commands

- #### [Introduction](#id-introduction)
- #### [Writing commands](#id-writing-commands)
  - #### [Generating commands](#id-generating-commands)
  - #### [Commands structure](#id-commands-structure)
  - #### [Defining input expectation](#id-defining-input-expectations)
- #### [Registering commands](#id-registering-commands)
- #### [Calling commands in runtime](#id-calling-commands-in-runtime)

## Introduction {#id-introduction}

In Athenna there is a more advanced way to create commands than just a closure command inside `routes/console` file. You
just need to extend the abstract class `Command` and implement her methods.

## Writing commands {#id-writing-commands}

In addition to the commands provided with Artisan, you may build your own custom commands. Commands are typically stored
in the `app/Console/Commands` directory; however, you are free to choose your own storage location as long as your commands
can be imported.

### Generating commands {#id-generating-commands}

To create a new command, you may use the `make:command` Artisan command. This command will create a new command class in
the `app/Console/Commands` directory and register it inside `commands` method of `app/Console/Kernel` file. Don't worry
if this directory does not exist in your application - it will be created the first time you run the `make:command` Artisan command:

```shell
node artisan make:command SendEmails
```

### Commands structure {#id-commands-structure}

After generating your command, you should define appropriate values for the `signature` and `description` properties of the
class. These properties will be used when displaying your command on the list screen. The `signature` property also
allows you to define your command's arguments expectations. The `handle` method will be called when your command is executed.
You may place your command logic in this method.

Let's take a look at an example command. Note that we are able to request any dependencies we need via the command's constructor
method. The Athenna service container will automatically inject all dependencies inside the container property of constructor:

```javascript
import { Command } from '@athenna/artisan'

export class SendEmails extends Command {
  /**
   * The name and signature of the console command.
   */
  signature = 'mail:send <email>'
  /**
   * The console command description.
   */
  description = 'Display welcome object.'

  /**
   * The welcome service dependency.
   *
   * @type {import('#app/Services/MailgunService').MailgunService}
   */
   #mailgunService

  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   *
   * @param {any} mailgunService
   */
  constructor(mailgunService) {
    super()

    this.#mailgunService = mailgunService
  }

  /**
   * Execute the console command.
   *
   * @param {string} email
   */
  async handle(email) {
    const message = 'Hello from Athenna!'

    await this.#mailgunService.send(email, message)
  }
}
```

:::tip
For greater code reuse, it is good practice keeping your console commands light and let them defer to application services
to accomplish their tasks. In the example above, note that we inject a service class to do the "heavy lifting" of sending the e-mails.
:::

### Defining input expectations {#id-defining-input-expectations}

When writing console commands, it is common to gather input from the user through arguments or options. Athenna makes it
very convenient to define the input you expect from the user using the `addFlags` method on your commands. The `addFlags`
method allows you to define any additional flag from [`commander`](https://www.npmjs.com/package/commander). Check out their
documentation to see all the flags available for your. See the example:

```javascript
import { Command } from '@athenna/artisan'

export class SendEmails extends Command {
  /**
   * The name and signature of the console command.
   */
  signature = 'mail:send <email>'
  /**
   * The console command description.
   */
  description = 'Display welcome object.'

  /**
   * The welcome service dependency.
   *
   * @type {import('#app/Services/MailgunService').MailgunService}
   */
   #mailgunService

  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   *
   * @param {any} mailgunService
   */
  constructor(mailgunService) {
    super()

    this.#mailgunService = mailgunService
  }

  /**
   * Set additional flags in the commander instance.
   * This method is executed when registering your command.
   *
   * @param {import('commander').Command} commander
   * @return {import('commander').Command}
   */
  public addFlags(commander) {
    const signature = '-s, --subject <subject>'
    const description = 'Set the subject of the email.'
    const defaultValue = 'Athenna'

    return commander.option(signature, description, defaultValue)
  }

  /**
   * Execute the console command.
   *
   * @param {string} email
   * @param {any} options
   */
  async handle(email, options) {
    const message = 'Hello from Athenna!'

    await this.#mailgunService.send(email, message, options.subject)
  }
}
```

### Registering commands {#id-defining-input-expectations}

All of your console commands are registered within your application's `app/Console/Kernel` class, which is your application's
"console kernel". The `ArtisanLoader` will register all the default commands from Athenna inside `commands` property:

```javascript
/**
* Register the commands for the application.
*
* @return void
*/
commands = [
  ...ArtisanLoader.loadHttp(),
]
```

By default, the `make:command` command will always create your command file and then register it inside `app/Console/Kernel`.
But if necessary, you may manually register commands by importing it inside `commands` property within your `app/Console/Kernel`
class. When Artisan boots, all the commands listed in this property will be resolved by the service container and registered with Artisan:

```javascript
/**
* Register the commands for the application.
*
* @return void
*/
commands = [
  ...ArtisanLoader.loadHttp(),
  import('App/Console/Commands/SendEmails'), // Define your command
]
```

### Calling commands in runtime {#id-calling-commands-in-runtime}

Sometimes you may wish to call other commands from an existing Artisan command or from any other part of your application.
You may do so using the `call` method from Artisan. This `call` method accepts the command string with it arguments and options:

```javascript
import { Artisan } from '@athenna/artisan'

Artisan.command('hello', async function () {
  await Artisan.call('make:controller TestController')

  this.success('Hello from Athenna!')
}).description('Athenna just says hello.')
```
