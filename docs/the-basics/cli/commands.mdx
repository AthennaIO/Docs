---
sidebar_position: 2

id: commands
title: Commands
hide_title: true
hide_table_of_contents: true
tags:
  - Getting Started
  - Architecture Concepts
  - The Basics
---

<nav aria-label="breadcrumbs">
  <ul class="breadcrumbs">
    <li class="breadcrumbs__item">
      <a class="breadcrumbs__link" href="/">
        üè†
      </a>
    </li>
    <li class="breadcrumbs__item">
      <a class="breadcrumbs__link">The Basics</a>
    </li>
    <li class="breadcrumbs__item">
      <a class="breadcrumbs__link">Cli</a>
    </li>
    <li class="breadcrumbs__item">
      <a class="breadcrumbs__link" href="/docs/the-basics/cli/commands">
        Commands
      </a>
    </li>
  </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Commands

- #### [Introduction](#id-introduction)
- #### [Writing commands](#id-writing-commands)
  - #### [Generating commands](#id-generating-commands)
  - #### [Commands structure](#id-commands-structure)
  - #### [Defining input expectation](#id-defining-input-expectations)
- #### [Registering commands](#id-registering-commands)
- #### [Registering custom templates](#id-registering-custom-templates)
- #### [Calling commands in runtime](#id-calling-commands-in-runtime)

## Introduction {#id-introduction}

In Athenna there is a more advanced way to create commands than just a closure command inside `routes/console` file. You
just need to extend the abstract class `Command` and implement her methods.

## Writing commands {#id-writing-commands}

In addition to the commands provided with Artisan, you may build your own custom commands. Commands are typically stored
in the `app/Console/Commands` directory; however, you are free to choose your own storage location as long as your commands
can be imported.

### Generating commands {#id-generating-commands}

To create a new command, you may use the `make:command` Artisan command. This command will create a new command class in
the `app/Console/Commands` directory and register it inside `commands` method of `app/Console/Kernel` file. Don't worry
if this directory does not exist in your application - it will be created the first time you run the `make:command` Artisan command:

```shell
node artisan make:command SendEmails
```

### Commands structure {#id-commands-structure}

After generating your command, you should define appropriate values for the `signature` and `description` properties of the
class. These properties will be used when displaying your command on the list screen. The `signature` property also
allows you to define your command's arguments expectations. The `handle` method will be called when your command is executed.
You may place your command logic in this method.

Let's take a look at an example command. Note that we are able to request any dependencies we need via the command's constructor
method. The Athenna service container will automatically inject all dependencies inside the container property of constructor:

```javascript
import { Command } from '@athenna/artisan'

export class SendEmails extends Command {
  /**
   * The name and signature of the console command.
   *
   * @return {string}
   */
  get signature() {
      return 'mail:send <email>'
  }

  /**
   * The console command description.
   *
   * @return {string}
   */
  get description() {
      return 'Display welcome object.'
  }

  /**
   * The welcome service dependency.
   *
   * @type {import('#app/Services/MailgunService').MailgunService}
   */
  #mailgunService

  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   *
   * @param {any} mailgunService
   */
  constructor(mailgunService) {
    super()

    this.#mailgunService = mailgunService
  }

  /**
   * Execute the console command.
   *
   * @param {string} email
   */
  async handle(email) {
    const message = 'Hello from Athenna!'

    await this.#mailgunService.send(email, message)
  }
}
```

:::tip
For greater code reuse, it is good practice keeping your console commands light and let them defer to application services
to accomplish their tasks. In the example above, note that we inject a service class to do the "heavy lifting" of sending the e-mails.
:::

### Defining input expectations {#id-defining-input-expectations}

When writing console commands, it is common to gather input from the user through arguments or options. Athenna makes it
very convenient to define the input you expect from the user using the `addFlags` method on your commands. The `addFlags`
method allows you to define any additional flag from [`commander`](https://www.npmjs.com/package/commander). Check out their
documentation to see all the flags available for your. See the example:

```javascript
import { Command } from '@athenna/artisan'

export class SendEmails extends Command {
  /**
   * The name and signature of the console command.
   *
   * @return {string}
   */
  get signature() {
      return 'mail:send <email>'
  }

  /**
   * The console command description.
   *
   * @return {string}
   */
  get description() {
      return 'Display welcome object.'
  }

  /**
   * The welcome service dependency.
   *
   * @type {import('#app/Services/MailgunService').MailgunService}
   */
   #mailgunService

  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   *
   * @param {any} mailgunService
   */
  constructor(mailgunService) {
    super()

    this.#mailgunService = mailgunService
  }

  /**
   * Set additional flags in the commander instance.
   * This method is executed when registering your command.
   *
   * @param {import('commander').Command} commander
   * @return {import('commander').Command}
   */
  public addFlags(commander) {
    const signature = '-s, --subject <subject>'
    const description = 'Set the subject of the email.'
    const defaultValue = 'Athenna'

    return commander.option(signature, description, defaultValue)
  }

  /**
   * Execute the console command.
   *
   * @param {string} email
   * @param {any} options
   */
  async handle(email, options) {
    const message = 'Hello from Athenna!'

    await this.#mailgunService.send(email, message, options.subject)
  }
}
```

### Registering commands {#id-registering-commands}

All of your console commands are registered within your application's `app/Console/Kernel` class, which is your application's
"console kernel". The `ArtisanLoader` will register all the default commands from Athenna inside `commands` property:

```javascript
/**
 * Register the commands for the application.
 *
 * @return {any[]}
 */
get commands() {
    return [
        ...ArtisanLoader.loadCommands(),
        ...HttpCommandsLoader.loadCommands(),
        ...TestCommandsLoader.loadCommands(),
    ]
}
```

By default, the `make:command` command will always create your command file and then register it inside `app/Console/Kernel`.
But if necessary, you may manually register commands by importing it inside `commands` property within your `app/Console/Kernel`
class. When Artisan boots, all the commands listed in this property will be resolved by the service container and registered with Artisan:

```javascript
/**
 * Register the commands for the application.
 *
 * @return {any[]}
 */
get commands() {
    return [
        ...ArtisanLoader.loadCommands(),
        ...HttpCommandsLoader.loadCommands(),
        ...TestCommandsLoader.loadCommands(),
        import('#app/Console/Commands/SendEmails')
    ]
}
```

### Registering custom templates {#id-registering-custom-templates}

The Artisan console's `make` commands are used to create a variety of classes, such as controllers, middlewares, commands, and tests.
These classes are generated using "templates" files that are populated with values based on your input. However, you may want
to make small changes to files generated by Artisan or even set your own templates to use in your custom `make` commands. To
accomplish this, you can set your custom template in the `templates` getter of `app/Console/Kernel` class as a `File` instance of
`@secjs/utils` package.

First we need to run the `template:customize` command to download all the templates inside the `templates` folder in our project
root:

```shell
node artisan template:customize
```

Now we have all template files inside `templates` folder. To use a different template file for an existent `make` command
of Artisan you will just need to set in `templates` getter of `app/Console/Kernel` class the custom template file with the
same name of the original one. Now in our `templates` folder we have the `__name__Exception.js.ejs` file, let's create a custom
template for it that removes all comments of the class:

```ejs
import { Exception } from '@athenna/core'

export class <%= namePascal %>Exception extends Exception {
  constructor(message, statusCode, code, help) {
    super(message, statusCode, code, help)
  }
}
```

:::caution

Remember that the file name needs to be `__name__Exception.js.ejs` to be replaced by Artisan original template.

:::

Now we just need to set this custom template file in our `templates` getter:

```javascript
import { Path, Folder } from '@secjs/utils'

/**
 * Register custom templates files.
 *
 * @return {import('@secjs/utils').File[] | Promise<any[]>}
 */
get templates() {
    return [
        ...HttpCommandsLoader.loadTemplates(),
        ...TestCommandsLoader.loadTemplates(),
        ...new Folder(Path.storage('templates')).loadSync().files
    ]
}
```

Now if we run the `node artisan make:exception` command, Artisan will use our custom template to generate the exceptions files.

:::tip

You can use the `Folder` class to load all files inside some folder once!

:::

:::info

As you can see, we are already loading the controller/middleware template from `HttpCommandsLoader` and the tests' template
from `TestCommandsLoader`!

:::

### Calling commands in runtime {#id-calling-commands-in-runtime}

Sometimes you may wish to call other commands from an existing Artisan command or from any other part of your application.
You may do so using the `call` method from Artisan. This `call` method accepts the command string with it arguments and options:

```javascript
import { Artisan } from '@athenna/artisan'

Artisan.command('hello', async function () {
  await Artisan.call('make:controller TestController')

  this.success('Hello from Athenna!')
}).description('Athenna just says hello.')
```
