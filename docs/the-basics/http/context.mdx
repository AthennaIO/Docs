---
sidebar_position: 4

id: context
title: Request Context
hide_title: true
hide_table_of_contents: true
tags:
- Getting Started
- Architecture Concepts
- The Basics
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">The Basics</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">Http</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/the-basics/http/context">Request Context</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Request Context

- #### [Introduction](#id-introduction)
- #### [The context object](#id-the-context-object)
  - #### [The request](#id-the-request)
  - #### [The response](#id-the-response)
  - #### [The params](#id-the-params)
  - #### [The queries](#id-the-queries)
  - #### [The data](#id-the-data)
- #### [The context object in middlewares](#id-the-context-object-in-middlewares)
  - #### [Handle middleware](#id-handle-middleware)
  - #### [Intercept middleware](#id-intercept-middleware)
  - #### [Terminate middleware](#id-terminate-middleware)

## Introduction {#id-introduction}

Athenna provides an object inside all Http handlers called `ctx`. This property is implemented by the `ContextContract`
interface.

## The context object {#id-the-context-object}

In Athenna as you can see in the previous documentation page of [`Middlewares`](/docs/the-basics/http/middlewares) and
[`Controllers`](/docs/the-basics/http/controllers) we are always destructuring the `ctx` property and using like this:

```javascript
Route.get('/welcome', ({ response }) => {
    response.status(200).send({ hello: 'world' })
})
```

But is the same of doing this:

```javascript
Route.get('/welcome', (ctx) => {
    ctx.response.status(200).send({ hello: 'world' })
})
```

The `ctx` object is little different for each type of handlers, and we will see all the differences previous in this
documentation page.

### The request object {#id-the-request}

Athenna `Request` class provides an object-oriented way to interact with the current HTTP request being handled by your
application as well as retrieve the ip, headers, body, and files that were submitted with the request.

#### The `ip` getter {#id-the-ip-getter}

With this getter you will be able to get the ip from where the requests was executed:

```javascript
Route.get('/welcome', ({ request }) => {
    console.log(request.ip) // 192.168.0.1

    /*....*/
})
```

#### The `method` getter {#id-the-method-getter}

With this getter you will be able to get the [`REST`](https://restfulapi.net/) method of your request:

```javascript
Route.get('/welcome', ({ request }) => {
    console.log(request.method) // GET

    /*....*/
})
```

#### The `hostUrl` getter {#id-the-hostUrl-getter}

With this getter you will be able to get the host url of the request concatenating the host:port of your application and the [`originalUrl`](/docs/the-basics/http/context#id-the-originalUrl-getter)
of the request:

```javascript
Route.get('/welcome', ({ request }) => {
    console.log(request.hostUrl) // http://localhost:1335/welcome

    /*....*/
})
```

#### The `baseUrl` getter {#id-the-baseUrl-getter}

With this getter you will be able to get the url of the route without the query params:

```javascript
Route.get('/welcome', ({ request }) => {
    console.log(request.baseUrl) // /welcome

    /*....*/
})
```

#### The `originalUrl` getter {#id-the-originalUrl-getter}

With this getter you will be able to get the original url with the query params:

```javascript
Route.get('/welcome', ({ request }) => {
    console.log(request.originalUrl) // /welcome?hello=world

    /*....*/
})
```

#### The `body`, `params`, `queries` and `headers` getters {#id-the-body-params-queries-and-headers-getters}

With these getters you will be able to retrieve all the data inside each one of then:

```javascript
Route.post('/welcome/:id', ({ request }) => {
    console.log(request.body) // { hello: 'world' }
    console.log(request.params) // { id: '1' }
    console.log(request.queries) // { world: 'hello' }
    console.log(request.headers) // { 'content-type': 'application/json' }

    /*....*/
})
```

#### The `input` and `payload` methods {#id-the-input-and-payload-methods}

With these methods you will be able to retrieve only one value per call from the request body:

```javascript
Route.post('/welcome/:id', ({ request }) => {
    const defaultValue = 'defaultValue'

    console.log(request.input('hello'), 'found') // 'world'
    console.log(request.input('not-found'), defaultValue) // 'defaultValue'

    console.log(request.payload('hello'), defaultValue) // 'world'
    console.log(request.payload('not-found'), defaultValue) // 'defaultValue'

    /*....*/
})
```

:::tip
As you can see, you can use the second argument of this type of methods to set the default value if the key
has not been found in your request.
:::

You may even use "dot" syntax to retrieve values that are nested within JSON arrays / objects:

```javascript
const name = request.input('user.name')
```

#### The `only` and `except` methods {#id-the-only-and-except-methods}

If you need to retrieve a subset of the input data, you may use the `only` and `except` methods. Both of
these methods accept a single array or a dynamic list of arguments:

```javascript
const input = request.only('username', 'password')
const input = request.only(['username', 'password'])

const input = request.except('credit_card');
const input = request.except(['credit_card'])
```

#### The `param`, `query` and `header` methods {#id-the-payload-param-query-and-header-methods}

With these methods you will be able to retrieve only one value per call from the above methods. You can also set a second parameter that will set the default value if the
first argument key doesn't exist:

```javascript
Route.post('/welcome/:id', ({ request }) => {
    const defaultValue = 'defaultValue'

    console.log(request.param('id'), defaultValue) // '1'
    console.log(request.param('not-found'), defaultValue) // 'defaultValue'

    console.log(request.query('world'), defaultValue) // 'hello'
    console.log(request.query('not-found'), defaultValue) // 'defaultValue'

    console.log(request.header('content-type'), defaultValue) // 'application/json'
    console.log(request.header('not-found'), defaultValue) // 'defaultValue'

    /*....*/
})
```

#### The `getFastifyRequest` method {#id-the-getFastifyRequest-method}

With this method you will be able to retrieve the vanilla Fastify request object to use more advanced getters and methods from Fastify:

```javascript
Route.get('/welcome', ({ request }) => {
    const fastifyRequest = request.getFastifyRequest()

    /*....*/
})
````

### The response object {#id-the-response}

Athenna `Response` class provides an object-oriented way to interact with the current HTTP response being handled by your
application as well set a status code and return the response to the client.

#### The `send` and `json` methods {#id-the-send-and-json-methods}

With these methods you are going to terminate the request sending a response body to the client. The `send` and `json` methods have the same signature, they do the exactly same
thing, you can use both to return your request:

```javascript
Route.get('/welcome', ({ response }) => {


    response.json({ hello: 'world' })
    // or -> response.send({ hello: 'world' })
})
```

#### The `helmet` method {#id-the-helmet-method}

With this method you are going to apply all the [`Helmet`](https://www.npmjs.com/package/helmet) response headers in your response:

```javascript
Route.get('/welcome', async ({ response }) => {
    if (condition) {
      // we apply the default options
      await response.helmet()
    } else {
      // we apply customized options
      await response.helmet({ frameguard: false })
    }
})
```

#### The `status` method {#id-the-status-method}

With this method you are going to apply the status code of your response:

```javascript
Route.get('/welcome', async ({ response }) => {
    response.status(200).json({ hello: 'World' })
})
```

#### The `header`, `safeHeader` and `removeHeader` methods {#id-the-header-safeHeader-and-removeHeader}

With these methods you can set custom header for your response, the `header` method will subscribe the already set headers, the `safeHeader` will only register the header
if the header is not yet registered and the `removeHeader` will remove a header from the response:

```javascript
Route.get('/welcome', async ({ response }) => {
    response.header('content-type', 'application/json')
    response.safeHeader('content-type', 'application/json')
    response.removeHeader('content-type')
})
```

#### The `redirectTo` method {#id-the-redirectTo-method}

With this method you can redirect your response to another url and with a different status code:

```javascript
Route.get('/hello', ctx => ctx.response.status(200))

Route.get('/welcome', async ({ response }) => {
    response.redirectTo('/hello', 200)
})
```

#### The `getFastifyResponse` method {#id-the-getFastifyResponse-method}

With this method you will be able to retrieve the vanilla Fastify response object to use more advanced getters and methods from Fastify:

```javascript
Route.get('/welcome', ({ response }) => {
    const fastifyResponse = response.getFastifyResponse()

    /*....*/
})
````

### The params object {#id-the-params}

Athenna `params` is just a simple object that contains the actual HTTP params of the request that is being handled by
your application.

### The queries object {#id-the-queries}

Athenna `queries` is just a simple object that contains the actual HTTP queries of the request that is being handled by
your application.

### The data object {#id-the-data}

Athenna `data` is just a simple object that you can use to set data inside to transfer between middlewares. This is really
useful for some cases. Let's see an example setting default pagination values if client has not sent page and limit:

```javascript
export class PaginationMiddleware {
  /**
   * Handle method is executed before the request gets in your controller.
   *
   * @param {import('@athenna/http').HandleContextContract} ctx
   */
  async handle({ request, data }) {
    const page = request.queries.page ? parseInt(request.queries.page) : 0
    const limit = request.queries.limit ? parseInt(request.queries.limit) : 10
    const resourceUrl = `${Config.get('http.domain')}${request.baseUrl}`

    data.pagination = {
      page,
      limit,
      resourceUrl,
    }
  }
}
```

And now is very simple to get this `pagination` object inside your handler:

```javascript
Route.get('/products', ({ response, data }) => {
    return response.send({ paginationObj: data.pagination })
}).middleware('PaginationMiddleware')
```

## The context object in middlewares {#id-the-context-object-in-middlewares}

### Handle middleware context {#id-handle-middleware}

In `handle` method of middlewares Athenna set the `HandleContextContract`. This ctx is the same of ContextContract.

### Intercept middleware context {#id-intercept-middleware}

In `intercept` method of middlewares Athenna set the `InterceptContextContract`. This ctx is quite the same of ContextContract,
but it has an additional properties `body` and `status`. You should always return the intercepted response body in intercept middlewares.

### Terminate middleware context {#id-terminate-middleware}

In `terminate` method of middlewares Athenna set the `TerminateContextContract`. This ctx is quite the same of ContextContract,
but it has an additional properties `body`, `status` and `responseTime`.


