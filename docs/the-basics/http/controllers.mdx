---
sidebar_position: 3

id: controllers
title: Controllers
hide_title: true
hide_table_of_contents: true
tags:
- Getting Started
- Architecture Concepts
- The Basics
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">The Basics</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">Http</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/the-basics/http/controllers">Controllers</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Controllers

- #### [Introduction](#id-introduction)
- #### [Writing controllers](#id-writing-controllers)
- #### [Resource controllers](#id-resource-controllers)
    - #### [Partial resource routes](#id-partial-resource-routes)
    - #### [Nested resources](#id-nested-resources)
- #### [Dependency injection and Controllers](#id-dependency-injection-and-controllers)

## Introduction {#id-introduction}

Instead of defining all of your request handling logic as closures in your route files, you may wish to organize this
behavior using "controller" classes. Controllers can group related request handling logic into a single class. For
example, a `UserController` class might handle all incoming requests related to users, including showing, creating,
updating, and deleting users. By default, controllers are stored in the `app/Http/Controllers` directory.

## Writing controllers {#id-writing-controllers}

Let's take a look at an example:

```javascript
export class UserController {
  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   */
  constructor() {}

  /**
   * Show the user.
   *
   * @params {import('@athenna/http').ContextContract} ctx
   */
  show({ response, params }) {
    return response.send(`User_${params.id}`)
  }
}
```

You can define a route to this controller method like so:

```javascript
Route.controller('UserController').get('/user/:id', 'show');

// or

Route.get('/user/:id', 'UserController.show');
```

When an incoming request matches the specified route URL, the `show` method on the `UserController`class will be invoked
and the route parameters will be passed to the method.

## Resource controllers {#id-resource-controllers}

If you think of each model in your application as a "resource", it is typical to perform the same sets of actions
against each resource in your application. For example, imagine your application contains a `Photo` model and a `Movie`
model. It is likely that users can create, read, update, or delete these resources.

Because of this common use case, Athenna resource routing assigns the typical creation, read, update, and delete ("CRUD")
routes to a controller with a single line of code. To get started, we can use the `make:controller` command's `--resource`
option to quickly create a controller to handle these actions:

```shell
node artisan make:controller PhotoController --resource
```

This command will generate a controller at `app/Http/Controllers/PhotoController`. The controller will contain a method
for each of the available resource operations. Next, you may register a resource route that points to the controller:

```javascript
Route.resource('photos', 'PhotoController')
```

This single route declaration creates multiple routes to handle a variety of actions on the resource. The generated
controller will already have methods stubbed for each of these actions. Remember, you can always get a quick overview
of your application's routes by running the `route:list` command.

```shell
node artisan route:list
```

### Partial resource routes {#id-partial-resource-routes}

When declaring a resource route, you may specify a subset of actions the controller should handle instead of the full
set of default actions:

```javascript
Route.resource('photos', 'PhotoController').only(['index', 'show'])

Route.resource('photos', 'PhotoController').except(['store', 'update', 'destroy'])
```

### Nested resources {#id-nested-resources}

Sometimes you may need to define routes to a nested resource. For example, a photo resource may have multiple comments
that may be attached to the photo. To nest the resource controllers, you may use "dot" notation in your route declaration:

```javascript
Route.resource('photos.comments', 'PhotoCommentController')
```

This route will register a nested resource that may be accessed with URLs like the following:

```shell
/photos/:photoId/comments/:commentId
```

## Dependency injection and Controllers {#id-dependency-injection-and-controllers}

The Athenna [`service container`](/docs/architecture-concepts/container) is used to resolve all Athenna controllers.
As a result, you are able to use any dependencies your controller may need in its constructor. The declared dependencies
will automatically be resolved and injected into the controller instance:

```javascript
export class UserController {
  /** @type {import('#app/Services/UserService').UserService} */
  #userService

  /**
   * Use the constructor to resolve any dependency of the Ioc container.
   */
  constructor(userService) {
    this.#userService = userService
  }

  /**
   * Show the user.
   *
   * @params {import('@athenna/http').ContextContract} ctx
   */
  async show({ response, params }) {
    const body = await this.#userService.findOne(params.id)

    return response.send(body)
  }
}
```
