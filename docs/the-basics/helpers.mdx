---
title: Helpers
sidebar_position: 3
description: Understand how to use all the Athenna Helpers from @athenna/common and other packages.
tags:
  - The Basics
  - Helpers
---

# Helpers

Understand how to use all the Athenna Helpers from @athenna/common and other packages.

## Introduction

Athenna includes a variety of "helpers" classes inside 
the `@athenna/common` package that comes by default 
installed in your application. Many of these classes are 
used by the framework itself; however, you are free to use 
them in your own applications if you find them convenient.

## Available helpers

- [`Clean`](/docs/the-basics/helpers#clean) - Remove falsy values 
from different data structures.
- [`Color`](/docs/the-basics/helpers#color) - The UI Kit of Athenna 
command line applications.
- [`Exception`](/docs/the-basics/helpers#exception) - Create errors with
more details to handle them easily.
- [`Exec`](/docs/the-basics/helpers#exec) - Simple helpers that executes
some operation, like executing a command in a child process.
- [`FakeApi`](/docs/the-basics/helpers#fakeapi) - Create a fake REST API
using `json` files to map the routes and their returns (similiar to [WireMock](https://wiremock.org/)).
- [`File`](/docs/the-basics/helpers#file) - Create, copy, move, 
delete and get information about files.
- [`Folder`](/docs/the-basics/helpers#folder) - Create, copy, move, 
delete and get information about folders.
- [`HttpClient`](/docs/the-basics/helpers#httpclient) - Make HTTP requests for
other servers with a human-friendly and powerful API.
- [`Is`](/docs/the-basics/helpers#is) - Validate if your data **is** 
equals to some type or pattern.
- [`Json`](/docs/the-basics/helpers#json) - Simple helpers to manipulate JSON.
- [`Module`](/docs/the-basics/helpers#module) - Simple helpers to manipulate
Node.js modules.
- [`Number`](/docs/the-basics/helpers#number) - Simple helpers to manipulate
numbers.
- [`Options`](/docs/the-basics/helpers#options) - Simple helpers to develop
API's (functions and methods) with good options and configurations for 
developers.
- [`Parser`](/docs/the-basics/helpers#parser) - Parse data from X to Y and Y to X.
- [`Path`](/docs/the-basics/helpers#path) - Get the full path to some file or 
folder starting from your application 
[PWD](https://www.computerhope.com/jargon/p/pwd.htm).
- [`Route`](/docs/the-basics/helpers#route) - Simple helpers to manipulate
route params, query params and more.
- [`String`](/docs/the-basics/helpers#string) - Simple helpers to manipulate
strings.
- [`Uuid`](/docs/the-basics/helpers#uuid) - Create customized UUID v4 and 
validate if they are valid.

### `Clean`

#### `Clean::cleanArray()`

Clean falsy and empty values from an array:

```typescript
import { Clean } from '@athenna/common'

const array = [
  '',
  1,
  null,
  undefined, 
  { joao: 'joao', lenon: null }, 
  {}
]

const cleanedArray = Clean.cleanArray(array)

console.log(cleanedArray)

/**
 * [
 *  1,
 *  { joao: 'joao', lenon: null }, 
 *  {}
 * ]
 */
```

The `cleanArray()` method supports two options, `removeEmpty` to remove empty 
values like `{}` and `[]` and `recursive` to recursivelly remove data
from objects and arrays:

```typescript
const cleanedArray = Clean.cleanArray(array, {
  removeEmpty: true,
  recursive: true
})

console.log(cleanedArray)

/**
 * [
 *  1, { joao: 'joao' }
 * ]
 */
```

#### `Clean::cleanObject()`

```typescript
const object = {
  key: 'value',
  emptyArray: [],
  emptyObject: {},
  object: { joao: 'joao' },
  nullValue: null,
  undefinedValue: undefined,
  arrayWithSubs: [null, 1, { joao: 'joao', lenon: null }, {}],
}

const cleanedObject = Clean.cleanObject(object)

console.log(cleanedObject) 
/**
 * {
 *  key: 'value',
 *  emptyArray: [],
 *  emptyObject: {},
 *  object: { joao: 'joao' },
 *  arrayWithSubs: [null, 1, { joao: 'joao', lenon: null }, {}],
 * }
 */
```

The `cleanObject()` method supports two options, `removeEmpty` to remove empty 
values like `{}` and `[]` and `recursive` to recursivelly remove data
from objects and arrays:

```typescript
const cleanedObject = Clean.cleanObject(object, {
  removeEmpty: true,
  recursive: true,
})

console.log(cleanedObject) 
/**
 * {
 *  key: 'value',
 *  object: { joao: 'joao' },
 *  arrayWithSubs: [1, { joao: 'joao' }],
 * }
 */
```

### `Color`

This helper uses [chalk](https://www.npmjs.com/package/chalk) 
library under the hood to create unique colors for Athenna
CLI applications. In this documentation we are going to focus
only in helpers that **`Color`** provides different from **chalk**.

#### `Color::apply()`

Apply the color engine of Athenna to some string. The color
engine execute [chalk](https://www.npmjs.com/package/chalk) 
methods under the hood. In the example bellow we are executing
`yellow()` and `bold()` method of 
[chalk](https://www.npmjs.com/package/chalk) in the word 
`World`:

```typescript
import { Color } from '@athenna/common'

const colorizedString = Color.apply('Hello ({yellow, bold} World)!')
```

:::info

The color of `World` word will be yellow with bold format.

:::

#### `Color::remove()`

Remove all the formats and colors of your string:

```typescript
import { Color } from '@athenna/common'

const noColorString = Color.remove(Color.yellow('Davi Mezencio'))
```

#### `Color::httpMethod()`

Get an instance of chalk with a determined color for each type 
of http method:

```typescript
import { Color } from '@athenna/common'

Color.httpMethod('GET').bold('Request Received')
Color.httpMethod('HEAD').bold('Request Received')
Color.httpMethod('POST').bold('Request Received')
Color.httpMethod('PUT').bold('Request Received')
Color.httpMethod('PATCH').bold('Request Received')
Color.httpMethod('DELETE').bold('Request Received')
Color.httpMethod('OPTIONS').bold('Request Received')
```

### `Exception`

In this documentation section we are going to cover only the 
helpers of the `Exception` class. You can learn more about 
exceptions when handling errors in your application. Those are 
the available documentation for error handling by application:

- [REST API](/docs/rest-api-application/error-handling)
- [CLI](/docs/cli-application/error-handling)

#### `Exception.toJSON()`

Get the informations of the exception as JSON:

```typescript
import { Exception } from '@athenna/common'

const exception = new Exception({
  status: 500,
  name: 'ErrorName',
  code: 'ERROR_CODE',
  message: 'Some exception has ocurred.',
  help: 'Try restarting your computer, should work.'
})

const json = exception.toJSON() // { status: 500, name: 'ErrorName', ... }
```

#### `Exception.prettify()`

Transform the exception to a human redable format:

```typescript
import { Exception } from '@athenna/common'

const exception = new Exception({
  status: 500,
  name: 'ErrorName',
  code: 'ERROR_CODE',
  message: 'Some exception has ocurred.',
  help: 'Try restarting your computer, should work.'
})

Logger.error(await exception.prettify())
```

### `Exec`

#### `Exec::sleep()`

Put the code to sleep for a determined amount of MS:

```typescript
import { Exec } from '@athenna/common'

await Exec.sleep(3000) // 3 seconds
```

#### `Exec::concurrently()`

Execute some callback concurrently for each value of 
the array:

```typescript
import { Exec } from '@athenna/common'

const array = [1, 2, 3]

const newArray = await Exec.concurrently(array, async (number) => {
  // Some sync operation just to simulate
  await Exec.sleep(1000)

  return number++
})
```

#### `Exec::command()`

Execute some command of your OS in a child process:

```typescript
import { Exec } from '@athenna/common'

const { stdout } = await Exec.command('ls -la')
```

If your command fails, Athenna will throw the 
`NodeCommandException`, to avoid this you can set the 
`ignoreErrors` option:

```typescript
import { Exec } from '@athenna/common'

const { stdout, stderr } = await Exec.command('ls -la', {
  ignoreErrors: true
})
```

#### `Exec::download()`

Download some file from some URL and get the `File` instance:

```typescript
import { Exec } from '@athenna/common'

// File helper class instance
const file = await Exec.download(Path.storage('file.txt'), 'https://athenna.io/file.txt')
```

#### `Exec::pagination()`

Create a pagination object for your API:

```typescript
import { Exec } from '@athenna/common'

const data = [{...}, {...}]

const paginateObject = await Exec.pagination(data, data.length, {
  page: 0,
  limit: 10,
  resourceUrl: Config.get('app.url')
})

console.log(paginateObject)
/**
 * {
 *  data: [{...}, {...}],
 *  meta: {
 *    itemCount: 2,
 *    totalItems: 2,
 *    totalPages: 1,
 *    currentPage: 0,
 *    itemsPerPage: 10,
 *  },
 *  links: {
 *    first: 'http://localhost:3000?limit=10',
 *    previous: 'http://localhost:3000?page=0&limit=10',
 *    next: 'http://localhost:3000?page=1&limit=10',
 *    last: 'http://localhost:3000?page=0&limit=10',
 *  } 
 * }
 */
```

### `FakeApi`

#### `FakeApi::start()`

Start the fake server on port `8989` and loading the path
`Path.resources('fake-api')`:

```typescript
import { FakeApi } from '@athenna/common'

await FakeApi.start()
```

:::note

You can change the server port and the path to read the
`json` files:

```typescript
import { FakeApi } from '@athenna/common'

await FakeApi.start(8989, Path.resources('path'))
```

:::

#### `FakeApi::stop()`

Stop the fake api server and call `FakeApi::recreate()` 
method to create a new server instance:

```typescript
import { FakeApi } from '@athenna/common'

await FakeApi.stop()
```

#### `FakeApi::isRunning()`

Verify if the fake api server is running:

```typescript
import { FakeApi } from '@athenna/common'

if (FakeApi.isRunning()) {
  // do something...
}
```

#### `FakeApi::listRoutes()`

List all the routes registered in the fake api server:

```typescript
import { FakeApi } from '@athenna/common'

const routes = FakeApi.listRoutes()

console.log(routes)
```

#### `FakeApi::registerFile()`

Register a route using a `json` file in the fake api:

```typescript
import { FakeApi } from '@athenna/common'

FakeApi.registerFile(Path.resources('fake-api/users.json'))
```

Content of `Path.resources('fake-api/users.json')` file:

```json
{
  "path": "/users",
  "method": "GET",
  "statusCode": 200, ðŸ‘ˆ // The response status code
  "body": [ ðŸ‘ˆ // The response body
    {
      "id": 1,
      "name": "JoÃ£o Lenon",
    },
    {
      "id": 2,
      "name": "Thais Gabriela",
    }
  ],
  "headers": { ðŸ‘ˆ // The response header
    "Content-Type": "application/json"
  }
}
```

#### `FakeApi::registerFolder()`

Recursively register all the `json` files of some folder:

```typescript
import { FakeApi } from '@athenna/common'

await FakeApi.registerFolder(Path.resources('fake-api'))
```

#### `FakeApi::build()`

Use this method to programatically build the routes u
sing the builder pattern:

```typescript
import { FakeApi } from '@athenna/common'
import type { RouteOptions } from 'fastify'

const options: RouteOptions = {}
const fakeApiBuilder = FakeApi.build()

const users = [
  {
    id: 1,
    name: 'JoÃ£o Lenon',
  },
  {
    id: 2,
    name: 'Thais Gabriela',
  }
]

fakeApiBuilder
  .path('/users')
  .method('GET')
  .statusCode(200)
  .body(users)
  .header({ 'Content-Type': 'application/json' })
  .register(options)
```

### `File`

#### `File.load()` & `File.loadSync()`

Creates the file is does not exist and also load the file information:

```typescript
import { File } from '@athenna/common'

const existent = new File(Path.storage('existent.txt'))
const nonExistent = new File('./nonExistent.txt', 'File content')

// Load the file info and content.
await existent.load({ withContent: true })  ðŸ‘ˆ

// Create and load the file info without the 
// content (be careful when loading big files).
nonExistent.loadSync() ðŸ‘ˆ
```

After loading process, the file will contain new informations:

- createdAt - The date when the file was created.
- accessedAt - The date when the file was last accessed.
- modifiedAt - The date when the file was last modified.
- fileSize - The size of the file in MB.
- content - The content of the file as `Buffer` if `withContent` was `true`.

#### `File.copy()` & `File.copySync()` 

Create a copy of the file in other location or with other name:

```typescript
import { File } from '@athenna/common'

const copiedFile = file.copySync('./copy-of-file.txt')
const copiedFile = await file.copy(Path.storage('copy-of-file.txt'))
```

To copy the file and load the content of the copy set the `withContent`
as `true`:

```typescript
import { File } from '@athenna/common'

const copiedFile = await file.copy(Path.storage('copy-of-file.txt'), {
  withContent: true ðŸ‘ˆ
})
```

When copying the file you can set the `mockedValues` to `true` to create 
a file with fake name:

```typescript
import { File } from '@athenna/common'

const copiedFile = await file.copy(Path.storage('copy-of-file.txt'), {
  mockedValues: true ðŸ‘ˆ
})
```

#### `File.move()` & `File.moveSync()` 

Move the file to other location:

```typescript
import { File } from '@athenna/common'

const movedFile = file.moveSync('./move-of-file.txt')               ðŸ‘ˆ
const movedFile = await file.move(Path.storage('move-of-file.txt')) ðŸ‘ˆ
```

To move the file and load the content of the move set the `withContent`
as `true`:

```typescript
import { File } from '@athenna/common'

const movedFile = await file.move(Path.storage('move-of-file.txt'), {
  withContent: true ðŸ‘ˆ
})
```

When moving the file you can set the `mockedValues` to `true` to create 
a file with fake name:

```typescript
import { File } from '@athenna/common'

const movedFile = await file.move(Path.storage('file-path.txt'), {
  mockedValues: true ðŸ‘ˆ
})
```

#### `File.remove()` & `File.removeSync()` 

Delete a file from the file system:

```typescript
import { File } from '@athenna/common'

file.removeSync()   ðŸ‘ˆ
await file.remove() ðŸ‘ˆ
```

#### `File.setContent()` & `File.setContentSync()`

Set the content of a file overwriting the existing content:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.txt', 'Hello')

file.setContentSync('Hello World!')   ðŸ‘ˆ
await file.setContent('Hello World!') ðŸ‘ˆ
```

#### `File.getContent()` & `File.getContentSync()`

Get the content of a file as `Buffer`:

```typescript
import { File } from '@athenna/common'

const contentBuffer = file.getContentSync()   ðŸ‘ˆ
const contentBuffer = await file.getContent() ðŸ‘ˆ
```

To save the content of the file in the instance set the `saveContent` as `true`:

```typescript
import { File } from '@athenna/common'

const content = await file.getContent({ saveContent: true }) ðŸ‘ˆ
```

#### `File.getContentAsString()` & `File.getContentAsStringSync()`

Same behavior of `getContent()`/`getContentSync()`, but return the content 
as `string`:

```typescript
import { File } from '@athenna/common'

const contentString = file.getContentAsStringSync()   ðŸ‘ˆ
const contentString = await file.getContentAsString() ðŸ‘ˆ
```

#### `File.getContentAsJson()` & `File.getContentAsJsonSync()`

Same behavior of `getContent()`/`getContentSync()`, but return the content as 
`object` if the content is a valid JSON string:

```typescript
import { File } from '@athenna/common'

const contentJSON = file.getContentAsJsonSync()   ðŸ‘ˆ
const contentJSON = await file.getContentAsJson() ðŸ‘ˆ
```

#### `File.getContentAsBuilder()` & `File.getContentAsBuilderSync()`

Same behavior of `getContent()`/`getContentSync()`, but return the content as 
an [`ObjectBuilder`](/docs/the-basics/helpers#object-builder) instance if the 
content is a valid JSON string:

```typescript
import { File } from '@athenna/common'

const contentObjectBuilder = file.getContentAsBuilderSync()   ðŸ‘ˆ
const contentObjectBuilder = await file.getContentAsBuilder() ðŸ‘ˆ
```

#### `File.append()` & `File.appendSync()`

Add content to the end of the file:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.txt', 'Hello')

file.appendSync(' World') ðŸ‘ˆ
await file.append('!\n')  ðŸ‘ˆ
```

#### `File.prepend()` & `File.prependSync()`

Add content to the top of the file:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.txt', 'World')

file.prependSync('ello ') ðŸ‘ˆ
await file.prepend('H')   ðŸ‘ˆ
```

#### `File.createReadStream()`

Create a [readable stream](https://nodejs.org/api/stream.html#readable-streams) 
instance of the file:

```typescript
const stream = file.createReadStream()
```

#### `File.createWriteStream()`

Create a [writable stream](https://nodejs.org/api/stream.html#writable-streams) 
instance of the file:

```typescript
const stream = file.createWriteStream()
```

#### `File.toJSON()`

Get the informations of the file as JSON:

```typescript
const infos = file.toJSON() ðŸ‘ˆ
```

#### `File.import()`

Import the file path if is a valid module:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.js', "console.log('hello')")

const module = await file.import() ðŸ‘ˆ
```

#### `File.safeImport()`

Same as `import()` method, but if the file is not a valid module the exception
will be ignored:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.txt', "console.log('hello')")

const module = await file.safeImport() ðŸ‘ˆ
```

Importing files that got any errors like syntax errors will also not throw:

```typescript
import { File } from '@athenna/common'

const file = new File('./file.js', "console.log('hello")

const module = await file.safeImport() ðŸ‘ˆ // Nothing happens
```

#### `File::safeRemove()`

Call for a delete operation without worrying about exceptions because the file
does not exist:

```typescript
import { File } from '@athenna/common'

await File.safeRemove(Path.storage('file.txt'))      ðŸ‘ˆ
await File.safeRemove(Path.storage('not-found.txt')) ðŸ‘ˆ // Will not throw
```

#### `File::exists()` & `File::existsSync()`

Verify if a file exists or not:

```typescript
if (File.existsSync('package.json')) {
  // do something
}

if (await File.exists('package.json')) {
  // do something
}
```

#### `File::isFile()` & `File::isFileSync()`

Verify if a file is a valid file or not:

```typescript
if (File.isFileSync('package.json')) {
  // do something
}

if (await File.isFile('package.json')) {
  // do something
}
```

#### `File::createFileOfSize()`

Create a fake file with determined size for testing purposes:

```typescript
const file = await File.createFileOfSize('fake.js', 1024 * 1024 * 100) ðŸ‘ˆ
```

### `Folder`

#### `Folder.load()` & `Folder.loadSync()`

Creates the folder if it does not exist and also load the folder information:

```typescript
import { Folder } from '@athenna/common'

const existent = new Folder(Path.storage('existent'))
const nonExistent = new Folder('./nonExistent')

// Load the folder info with sub folders and with file contents.
await existent.load({ withSub: true, withContent: true })  ðŸ‘ˆ

// Create and load the folder info without the 
// content (be careful when loading big files).
nonExistent.loadSync() ðŸ‘ˆ
```

After loading process, the folder will contain new informations:

- createdAt - The date when the folder was created.
- accessedAt - The date when the folder was last accessed.
- modifiedAt - The date when the folder was last modified.
- folderSize - The size of the folder in MB.

#### `Folder.copy()` & `Folder.copySync()` 

Create a copy of the folder in other location or with other name:

```typescript
import { Folder } from '@athenna/common'

const copiedFolder = folder.copySync('./copy-of-folder')
const copiedFolder = await folder.copy(Path.storage('copy-of-folder'))
```

To copy the folder and load the sub folders and the content of the 
copy set the `withSub` and `withContent` as `true`:

```typescript
import { Folder } from '@athenna/common'

const copiedFolder = await folder.copy(Path.storage('copy-of-folder'), {
  withSub: true,    ðŸ‘ˆ
  withContent: true ðŸ‘ˆ
})
```

When copying the folder you can set the `mockedValues` to `true` to copy the 
files with fake names:

```typescript
import { Folder } from '@athenna/common'

const copiedFolder = await folder.copy(Path.storage('copy-of-file'), {
  mockedValues: true ðŸ‘ˆ
})
```

#### `Folder.move()` & `Folder.moveSync()` 

Move the folder to other location:

```typescript
import { Folder } from '@athenna/common'

const movedFolder = folder.moveSync('./move-of-folder')               ðŸ‘ˆ
const movedFolder = await folder.move(Path.storage('move-of-folder')) ðŸ‘ˆ
```

To move the folder and load the sub folders and the content of the 
move set the `withSub` and `withContent` as `true`:

```typescript
import { Folder } from '@athenna/common'

const movedFolder = await folder.move(Path.storage('move-of-folder'), {
  withSub: true,    ðŸ‘ˆ
  withContent: true ðŸ‘ˆ
})
```

When moving the folder you can set the `mockedValues` to `true` to move the 
files with fake names:

```typescript
import { Folder } from '@athenna/common'

const movedFolder = await folder.move(Path.storage('file-path'), {
  mockedValues: true ðŸ‘ˆ
})
```

#### `Folder.remove()` & `Folder.removeSync()` 

Delete a folder from the folder system:

```typescript
import { Folder } from '@athenna/common'

folder.removeSync()   ðŸ‘ˆ
await folder.remove() ðŸ‘ˆ
```

#### `Folder.toJSON()`

Get the informations of the folder as JSON:

```typescript
const infos = folder.toJSON() ðŸ‘ˆ
```

#### `Folder.getFilesByPattern()`

Get all the files of a folder using a glob pattern:

```typescript
const files = folder.getFilesByPattern('**/*.js') ðŸ‘ˆ
```

#### `Folder.getFoldersByPattern()`

Get all the folders of a folder using a glob pattern:

```typescript
const folders = folder.getFoldersByPattern('**/*') ðŸ‘ˆ
```

#### `Folder::safeRemove()`

Call for a delete operation without worrying about exceptions because the folder
does not exist:

```typescript
import { Folder } from '@athenna/common'

await Folder.safeRemove(Path.storage('folder'))    ðŸ‘ˆ
await Folder.safeRemove(Path.storage('not-found')) ðŸ‘ˆ // Will not throw
```

#### `Folder::exists()` & `Folder::existsSync()`

Verify if a folder exists or not:

```typescript
if (Folder.existsSync('app')) {
  // do something
}

if (await Folder.exists('app')) {
  // do something
}
```

#### `Folder::isFolder()` & `Folder::isFolderSync()`

Verify if a folder is a valid folder or not:

```typescript
if (Folder.isFolderSync('app')) {
  // do something
}

if (await Folder.isFolder('app')) {
  // do something
}
```

#### `Folder::size()` & `Folder::sizeSync()`

Get the size of the folder in MB:

```typescript
if (Folder.sizeSync('app') === 100) {
  // do something
}

if (await Folder.size('app')  === 100) {
  // do something
}
```

### `HttpClient`

Coming soon

### `Is`

Coming soon

### `Json`

Coming soon

### `Module`

Coming soon

### `Number`

Coming soon

### `Options`

Coming soon

### `Parser`

Coming soon

### `Path`

Coming soon

### `Route`

Coming soon

### `String`

Coming soon

### `Uuid`

Coming soon
