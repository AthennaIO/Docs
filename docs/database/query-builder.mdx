---
sidebar_position: 2

id: query-builder
title: Query Builder
hide_title: true
hide_table_of_contents: true
tags:
- ORM
- Database
- Query builder
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">Database</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/database/query-builder">Query Builder</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Database: Query Builder

- #### [Introduction](#id-introduction)
- #### [Running database queries](#id-running-database-queries)
    - #### [Raw expressions](#id-raw-expressions)
    - #### [Get the client of driver](#id-get-the-client-of-driver)
- #### [Aggregates](#id-aggregates)
- #### [Select statements](#id-select-statements)
- #### [Where clauses](#id-where-clauses)
    - #### [Or where clauses](#id-or-where-clauses)
    - #### [Where not clauses](#id-where-not-clauses)
    - #### [Additional where clauses](#id-additional-where-clauses)
- #### [Ordering, limit & skip](#id-ordering-limit-skip)
- #### [Pagination](#id-pagination)
- #### [Relations](#id-relations)

## Introduction {#id-introduction}

Athenna database query builder provides a convenient, fluent interface to creating and running database queries. It can
be used to perform most database operations in your application and works perfectly with all of Athenna supported database
drivers.

## Running database queries {#id-running-database-queries}

#### Retrieve all rows from a table {#id-retrieve-all-rows-from-a-table}

You may use the `buildTable` method provided by the `Database` facade to begin a query. The `buildTable` method returns a fluent
query builder instance for the given table, allowing you to chain more constraints onto the query and then finally retrieve
the results of the query using the `findMany` method:

```javascript
import { Database } from '@athenna/database'

const users = await Database
        .buildTable('users')
        .buildSelect('id', 'name')
        .buildWhereILike({ name: '%Valmir Barbosa%' })
        .buildOrderBy('name', 'ASC')
        .findMany()
```

Athenna also provides the `collection` method that returns an `Collection` instance containing the results of the query.
You may access each column's value using the `all` method:

```javascript
const collection = await Database
        .buildTable('users')
        .buildSelect('id', 'name')
        .buildWhereILike({ name: '%Valmir Barbosa%' })
        .buildOrderBy('name', 'ASC')
        .collection()

const users = collection.all()
```

:::tip
Athenna collections provide a variety of extremely powerful methods for mapping and reducing data. For more information
on Athenna collections, check out the [collection documentation](/docs/digging-deeper/collections).
:::

#### Retrieve a single row {#id-retrieve-a-single-row}

If you just need to retrieve a single row from a database table, you may use the `Database` facade's `find` method. This
method will return a single object:

```javascript
const user = await Database
        .buildTable('users')
        .buildSelect('id', 'name')
        .buildWhere({ name: 'Rodrigo Kamada' })
        .find()
```

### Raw expressions {#id-raw-expressions}

Sometimes you may need to create your query using pure SQL. To create a raw query, you may use the `raw` method provided
by the `Database` facade:

```javascript
const users = await Database.raw('SELECT * FROM users')
```

:::caution
You should be extremely careful to avoid creating SQL injection vulnerabilities using the `raw` method.
:::

### Get the client of driver {#id-get-the-client-of-driver}

To get the vanilla client of your connection driver you can use the `getClient` method:

```javascript
const client = Database.getClient()

const result = await client
        .createQueryBuilder('user')
        .where('user.id = :id', { id: 1 })
        .andWhere('user.status = :status', { status: 'ACTIVE' })
        .getMany()
```

## Aggregates {#id-aggregates}

The query builder also provides a variety of methods for retrieving aggregate values like **count, max, min, avg,** and **sum**.
You may call any of these methods after constructing your query:

```javascript
const numberOfUsers = await Database.buildTable('users').count()
const maxPriceOrder = await Database.buildTable('orders').max('price')
```

Of course, you may combine these methods with other clauses to fine-tune how your aggregate value is calculated:

```javascript
const priceAverage = await Database
        .buildTable('orders')
        .buildWhere('finalized', true)
        .avg('price')
```

## Select statements {#id-select-statements}

You may not always want to select all columns from a database table. Using the `buildSelect` method, you can specify a
custom "select" clause for the query:

```javascript
const { id, name } = await Database
        .buildTable('users')
        .buildSelect('id', 'name')
        .find()
```

If you already have a query builder instance, and you wish to add a column to its existing select clause, you may use the
`buildAddSelect` method:

```javascript
const { id, name } = await Database
        .buildTable('users')
        .buildSelect('id')
        .buildAddSelect('name')
        .find()
```

:::tip
The `buildAddSelect` method is very useful when you want to show hidden fields of [models](/docs/database/orm).
:::

## Where clauses {#id-where-clauses}

You may use the query builder's `buildWhere` method to add "where" clauses to the query. The most basic call to the `buildWhere`
method requires three arguments. The first argument is the name of the column. The second argument is an operator, which can be
any of the database's supported operators. The third argument is the value to compare against the column's value.

For example, the following query retrieves users where the value of the `votes` column is equal to `100` and the value of the `age`
column is greater than `35`:

```javascript
const user = await Database
        .buildTable('users')
        .buildWhere('votes', '=', 100)
        .buildWhere('age', '>', 35)
        .find()
```

For convenience, if you want to verify that a column is `=` to a given value, you may pass the value as the second argument
to the `buildWhere` method. Athenna will assume you would like to use the `=` operator:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhere('votes', 100)
        .findMany()
```

As previously mentioned, you may use any operator that is supported by your database system:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhere('votes', '>=', 100)
        .findMany()

const users = await Database
        .buildTable('users')
        .buildWhere('votes', '<>', 100)
        .findMany()

const users = await Database
        .buildTable('users')
        .buildWhere('name', 'like', 'J%')
        .findMany()
```

You may also pass an object of conditions, but remember that when using objects the operation is always going to be `=`:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhere({ name: 'Jo√£o Lenon', deletedAt: null })
        .findMany()
```

### Or where clauses {#id-or-where-clauses}

When chaining together calls to the query builder's `buildWhere` method, the "where" clauses will be joined together using
the `AND` operator. However, you may use the `buildOrWhere` method to join a clause to the query using the `OR` operator.
The `buildOrWhere` method accepts the same arguments as the `buildWhere` method:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhere('votes', '>', 100)
        .buildOrWhere('name', 'Jo√£o')
        .findMany()
```

### Where not clauses {#id-where-not-clauses}

The `buildWhereNot` and `buildOrWhereNot` methods may be used to negate a given constraint. For example, the following query
excludes the product with `id` ten:

```javascript
const products = await Database
        .buildTable('products')
        .buildWhereNot('id', 10)
        .findMany()
```

### Additional where clauses {#id-additional-where-clauses}

> buildWhereBetween / buildWhereNotBetween

The `buildWhereBetween` method verifies that a column's value is between two values:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereBetween('votes', [1, 100])
        .findMany()
```

The `buildWhereNotBetween` method verifies that a column's value lies outside two values:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereNotBetween('votes', [1, 100])
        .findMany()
```

> buildWhereIn / buildWhereNotIn

The `buildWhereIn` method verifies that a given column's value is contained within the given array:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereIn('id', [1, 2, 3])
        .findMany()
```

The `buildWhereNotIn` method verifies that the given column's value is not contained in the given array:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereNotIn('id', [1, 2, 3])
        .findMany()
```

> buildWhereNull / buildWhereNotNull

The `buildWhereNull` method verifies that the value of the given column is `NULL`:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereNull('deletedAt')
        .findMany()
```

The `buildWhereNotNull` method verifies that the column's value is not `NULL`:

```javascript
const users = await Database
        .buildTable('users')
        .buildWhereNotNull('deletedAt')
        .findMany()
```

## Ordering, limit & skip {#id-ordering-limit-skip}

Coming soon...

## Pagination {#id-pagination}

Coming soon...

## Relations {#id-relations}

The database connection will always bootstrap with your [models](/docs/database/orm) configured, so the `Database` facade
will always know all the **relations of your table**:

```javascript
// One user has many products
const user = await Database
        .buildTable('users')
        .buildIncludes('products')
        .find()

const userProducts = user.products // [...]
```

### Including sub relations {#id-including-sub-relations}

To include sub relations you can simply call `buildIncludes` method again, and use the alias of your relation as param:

```javascript
const user = await Database
        .buildTable('users')
        .buildIncludes('products')
        .buildIncludes('products.productDetails')
        .find()

const userProducts = user.products // [...]
const detailsOfFirstProduct = user.products[0].productDetails // [...]
```

You can also use the same syntax for other methods:

```javascript
const user = await Database
        .buildTable('users')
        .buildIncludes('products')
        .buildIncludes('products.productDetails')
        .buildSelect('users.name', 'products.name', 'productDetails.id')
        .buildWhere('productDetails.status', 'ACTIVE')
        .find()
```
