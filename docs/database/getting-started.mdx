---
sidebar_position: 1

id: getting-started
title: Getting Started
hide_title: true
hide_table_of_contents: true
tags:
- ORM
- Database
- Digging Deeper
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">Database</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/database/getting-started">Getting Started</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Database: Getting Started

- #### [Introduction](#id-introduction)
- #### [Installation](#id-installation)
- #### [Configuration](#id-configuration)
    - #### [Available connection drivers](#id-available-connection-drivers)
    - #### [Overview of some environment variables](#id-overview-of-some-environment-variables)
- #### [Running queries](#id-running-queries)
    - #### [Using multiple database connections](#id-using-multiple-database-connections)
- #### [Database transactions](#id-database-transactions)

## Introduction {#id-introduction}

Almost every modern application interacts with a database. Athenna makes interacting with databases extremely simple across
a variety of supported databases using raw SQL, a fluent query builder, and the ORM.

## Installation {#id-installation}

Athenna provides a very simple command inside `@athenna/cli` package to easily install and configure the database package
in your project. In your project root path run:

```shell
athenna install:database
```

This command will do the following operations in your project:

- Install [`pg`](https://www.npmjs.com/package/pg) package
- Install [`@athenna/database`](https://github.com/AthennaIO/Database) package
- Create `config/database.js` file
- Add the database provider to `config/app.js` file in providers property
- Add the database commands and templates to `app/Commands/Kernel.js`
- Add environment variables to your `.env` file
- Create `docker-compose.yaml` file
- Lint your project

:::tip

PostgreSQL is the default database of `install:database` command. If you want to configure for MySQL database use the `--db=mysql`
argument.

:::

## Configuration {#id-configuration}

All the configuration options for your application's database behavior is housed in the `config/database.js` configuration file.
This file allows you to configure your application's database connections, so be sure to review each of the available connections
and their options. We'll review a few common options below.

### Available connection drivers {#id-available-connection-drivers}

Each database connection is powered by a "driver". The driver determines how and where the data is actually transported.
The following database connection drivers are available in every Athenna application. An entry for most of these drivers is
already present in your application's `config/database.js` configuration file, so be sure to review this file to become
familiar with its contents:

<table>
    <thead>
    <tr>
        <th>Name</th>
        <th>Website</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td><code>mysql</code></td>
        <td><a target="_blank" href="https://www.mysql.com/">https://www.mysql.com/</a></td>
    </tr>
    <tr>
        <td><code>postgresql</code></td>
        <td><a target="_blank" href="https://www.postgresql.org/">https://www.postgresql.org/</a></td>
    </tr>
    </tbody>
</table>

### Overview of some environment variables {#id-overview-of-some-environment-variables}

After installing the database component using the Athenna CLI you can check your `.env` file in your project root path,
the Athenna CLI have added some environment variables there to help you connect to your database. These variables are:

```dotenv
DB_CONNECTION=postgres
DB_HOST=127.0.0.1
DB_PORT=(5432)
DB_DATABASE=database
DB_USERNAME=root
DB_PASSWORD=root
DB_SYNCHRONIZE=(true)
DB_AUTO_CONNECT=(true)
```

Let's focus in **DB_CONNECTION, DB_SYNCHRONIZE and DB_AUTO_CONNECT** variables:

#### DB_CONNECTION

This variable specify for Athenna what is the default connection name that should be used by `Database` facade when running
database operations.

#### DB_SYNCHRONIZE

This variable are useful when running your application locally, If `DB_SYNCHRONIZE` is true, than TypeORM will read the
schema of all your models and auto create the tables for your in your database. This variable **should be used only for
development purpose**. Do NOT use synchronize in production environment (might have data losses).

#### DB_AUTO_CONNECT

This variable specify for Athenna if the default connection should be auto connected inside `DatabaseProvider`. We set the
value of this variable as true when bootstrapping the application by `bootstrap/main.js` file, but when running the application
from `artisan` we set this variable to false.

:::tip

Before going through the documentation, remember to run [`docker-compose up -d`](https://docs.docker.com/compose/) to start
up the database in your machine.

:::

## Running queries {#id-running-queries}

Once you have configured your database connection, you may run queries using the `Database` facade. The `Database` facade
provides **executors** methods for each type of query, here are the more relevant:

- find
- findMany
- create
- createMany
- update
- delete

We'll review why and how to use all of these methods later. The methods that start with `build...` means you are building
a query, and to execute the query you need to call one of the **executors** methods.

To run any of the below queries, you may use first the `buildTable` method to specify what is the table that should be used
for your operations:

```javascript
import { Database } from '@athenna/database'

Database.buildTable('users')
```

Everytime that you use the `Database` facade you are using a different instance of `DatabaseImpl` class. This means that you
would need to call `buildTable` method everytime for different queries. To get around this, you can save the instance in a local
variable:

```javascript
import { Database } from '@athenna/database'

const userQuery = Database.buildTable('users') // First instance of Database
const orderQuery = Database.buildTable('orders') // Second instance of Database
const productsQuery = Database.buildTable('products') // Third instance of Database
```

#### Running a find query {#id-running-a-find-query}

The `find` method is useful to retrieve only one record that match the query statements from database:

```javascript
const query = Database.buildTable('users')

const { id, name } = await query
    .buildSelect('id', 'name')
    .buildWhere({ id: 10 })
    .find()
```

#### Running a findMany query {#id-running-a-findMany-query}

The `findMany` method is useful to retrieve more than one record that match the query statements from database:

```javascript
const query = Database.buildTable('users')

const users = await query
    .buildSelect('id', 'name')
    .buildWhereNull('deletedAt')
    .buildWhereLike('name', '%Lenon%')
    .buildOrderBy('name', 'DESC')
    .findMany()
```

#### Running a create query {#id-running-a-create-query}

The `create` method is useful to create one record in database:

```javascript
const query = Database.buildTable('users')

const user = await query.create({ name: 'Victor Tesoura' })
```

#### Running a createMany query {#id-running-a-createMany-query}

The `createMany` method is useful to create many records in database:

```javascript
const query = Database.buildTable('users')

const users = await query.createMany([
    { name: 'Victor Tesoura' },
    { name: 'Jo√£o Lenon' }
])
```

#### Running an update query {#id-running-an-update-query}

The `update` method is useful to update one or more records based in statements in database:

```javascript
const query = Database.buildTable('users')

const users = await query
    .buildSelect('id', 'name')
    .buildWhereIn('id', [1, 2])
    .buildOrderBy('name', 'ASC')
    .update({ name: 'Danrley Morais' })
```

#### Running a delete query {#id-running-an-update-query}

The `delete` method is useful to delete one or more records based in statements in database:

```javascript
const query = Database.buildTable('users')

await query.buildWhereBetween('id', [1, 10]).delete()
```

### Using multiple database connections {#id-using-multiple-database-connections}

If your application defines multiple connections in your `config/database.js` configuration file, you may access each
connection via the `connection` method provided by the `Database` facade. The connection name passed to the `connection`
method should correspond to one of the connections listed in your `config/database.js` configuration file:

```javascript
const query = await Database.connection('mysql').connect()

const users = await query
    .buildTable('users')
    .buildSelect('id', 'name')
    .buildWhereNotIn('id', [1, 2])
    .buildOrderBy('name', 'ASC')
    .findMany()
```

## Database transactions {#id-database-transactions}

Coming soon...
