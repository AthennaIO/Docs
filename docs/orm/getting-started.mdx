---
sidebar_position: 1

id: getting-started
title: Getting Started
hide_title: true
hide_table_of_contents: true
tags:
- ORM
- Database
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">ORM</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/orm/getting-started">Getting Started</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# ORM: Getting Started

- #### [Introduction](#id-introduction)
- #### [Generating models](#id-generating-models)
- #### [Model conventions](#id-model-conventions)
    - #### [Table names](#id-table-names)
    - #### [Primary keys](#id-primary-keys)
    - #### [Default attributes values](#id-default-attributes-values)
    - #### [Schemas](#id-schemas)
    - #### [Database connections](#id-database-connections)
- #### [Retrieving models](#id-retrieving-models)
    - #### [Building queries](#id-building-queries)
    - #### [Refreshing models](#id-refreshing-models)
- #### [Collections](#id-collections)
- #### [Retrieve single models & Aggregates](#id-retrieve-single-models-and-aggregates)

## Introduction {#id-introduction}

Athenna has an object-relational mapper (ORM) that makes it enjoyable to interact with your database. When using the Athenna ORM,
each database table has a corresponding "Model" that is used to interact with that table. In addition to retrieving records from
the database table, the models allow you to insert, update, and delete records from the table as well.

:::tip
Before getting started, be sure to configure a database connection in your application's `config/database.js` configuration file.
For more information on configuring your database, check out [`the database configuration documentation.`](/docs/database/getting-started#id-configuration)
:::

## Generating models {#id-generating-models}

To get started, let's create a model. Models typically live in the `app/Models` directory and extend the
[`Model`](https://github.com/AthennaIO/Database/blob/develop/src/Models/Model.js) class. You may use the `make:model` Artisan
command to generate a new model:

```shell
node artisan make:model Flight
```

## Model conventions {#id-model-conventions}

Models generated by the `make:model` command will be placed in the `app/Models` directory. Let's examine a basic model
class and discuss some of Model's key conventions:

```javascript
import { Model } from '@athenna/database'

export class Flight extends Model {

}
```

### Table names {#id-table-names}

After glancing at the example above, you may have noticed that we did not tell the model which database table corresponds to
our `Flight` model. By convention, the "snake_case", plural name of the class will be used as the table name unless another
name is explicitly specified. So, in this case, the model will assume the `Flight` model stores records in the `flights` table,
while an `AirTrafficController` model would store records in an `air_traffic_controllers` table.

If your model's corresponding database table does not fit this convention, you may manually specify the model's table name by
defining a static getter `table` on the model:

```javascript
import { Model } from '@athenna/database'

export class Flight extends Model {
  /**
   * Set the table name of this model instance.
   *
   * @return {string}
   */
  static get table() {
      return 'my_flights'
  }

  /*...*/
}
```

### Primary keys {#id-primary-keys}

The model will also assume that each model's corresponding database table has a primary key column named id. If necessary,
you may define a static getter `primaryKey` on your model to specify a different column that serves as your model's primary
key:

```javascript
import { Model } from '@athenna/database'

export class Flight extends Model {
  /**
   * Set the primary key of your model.
   *
   * @return {string}
   */
  static get primaryKey() {
      return 'id'
  }

  /*...*/
}
```

### Default attributes vales {#id-default-attributes-values}

By default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default values
for some of your model's attributes, you may define a static getter `attributes` on your model:

```javascript
import { Uuid } from '@athenna/common'
import { Model } from '@athenna/database'

export class Flight extends Model {
  /**
   * Set the default attributes of your model.
   *
   * @return {any}
   */
  static get attributes() {
      return {
          id: Uuid.generate()
      }
  }

  /*...*/
}
```

As you can see we are defining an `id` property in our static getter `attributes`. This property will have the value of a generated
uuid randomly everytime that Athenna calls the `attributes` getter. This means that `attributes` is totally different from the default
values that you set in your database migrations. Athenna will call the `attributes` getter everytime that `create` and `createMany`
methods are called, this means that a new uuid will be generated for each call:

```javascript
import { Flight } from '#app/Models/Flight'

const flight1 = await Flight.create()
const flight2 = await Flight.query().create()

console.log(flight1.id) // -> 43bf66ec-658a-4f59-8f89-2aac5ae96e6a
console.log(flight2.id) // -> cbe35c9c-60f3-11ed-9b6a-0242ac120002
```

:::tip
But always remember that if you have already set the attribute in one of these methods, the `attributes` getter will not subscribe then:

```javascript
import { Flight } from '#app/Models/Flight'

// Setting my own id attribute
const flight = await Flight.create({ id: '299dabf8-60f4-11ed-9b6a-0242ac120002' })

console.log(flight.id) // -> 299dabf8-60f4-11ed-9b6a-0242ac120002
```
:::

### Schemas {#id-schemas}

The schemas are very important for Athenna models to work as a "dictionary". When you define a value in your schema you need to
use the `Column` class to define all the options available in your database:

```javascript
import { Model, Column } from '@athenna/database'

export class Flight extends Model {
  /**
   * The default schema for model instances.
   *
   * @return {any}
   */
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      title: Column.string('flight_title'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
    }
  }
}
```

### UUID Keys {#id-uuid-keys}

Instead of using auto-incrementing integers as your model's primary keys, you may choose to use UUIDs instead. UUIDs are
universally unique alphanumeric identifiers that are 36 characters long.

If you would like a model to use a UUID key instead of an auto-incrementing integer key, you may use the `Column.autoIncrementedUuid`
method in your primary key and then set what is your primary key (the default is already the `id` property). Athenna will automatically
identify if you are using UUID's in your primary key and generate a new uuid after creating some record in your database:

```javascript
import { Model, Column } from '@athenna/database'

export class Article extends Model {
  /**
   * Set the primary key of your model.
   *
   * @return {string}
   */
  static get primaryKey() {
      return 'id'
  }

  /**
   * The default schema for model instances.
   *
   * @return {any}
   */
  static schema() {
    return {
      id: Column.autoIncrementedUuid(),
      title: Column.string('my_title'),
    }
  }
}

const article = await Article.create({ title: 'Traveling to Mozambique' })

console.log(article.id) // -> 84b7cdcf-9e97-4547-ae3a-ec652c08f5ac
```

### Database connections {#id-database-connections}

By default, all models will use the default database connection that is configured for your application. If you would like
to specify a different connection that should be used when interacting with a particular model, you should define a
static getter `connection` on the model:

```javascript
import { Model } from '@athenna/database'

export class Article extends Model {
  /**
   * Set the db connection that this model instance will work with.
   *
   * @return {string}
   */
  static get connection() {
      return 'mysql'
  }

  /*...*/
}
```

## Retrieving models {#id-retrieving-models}

Once you have created a model and its associated database table, you are ready to start retrieving data from your database. You can think of each model as a
powerful query builder allowing you to fluently query the database table associated with the model. The model's `findMany` method will retrieve all the records
from the model's associated database table:

```javascript
import { Flight } from '#app/Models/Flight'

const flights = await Flight.findMany()

flights.forEach(flight => console.log(flight.name))
```

### Building queries {#id-building-queries}

The model `findMany` method will return all the results in the model's table. However, since each model serves as a query builder, you may invoke the `query`
method first and add additional constraints to queries and then invoke the `findMany` method to retrieve the results:

```javascript
const flights = await Flight.query()
        .where('active', 1)
        .orderBy('name')
        .limit(10)
        .findMany()
```

:::tip
Since models are query builders, you should review all the methods provided by [`Athenna's query builder`](https://athenna.io/docs/database/query-builder).
You may use any of these methods when writing your model queries.
:::

### Refreshing models {#id-refreshing-models}

If you already have an instance of an model that was retrieved from the database, you can "refresh" the model using the `fresh` and `refresh` methods. The `fresh`
method will re-retrieve the model from the database. The existing model instance will not be affected:

```javascript
const flight = await Flight.find({ number: 'FR 900' })

const freshFlight = await flight.fresh()
```

The `refresh` method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:

```javascript
const flight = await Flight.find({ number: 'FR 900' })

flight.number = 'FR 456'

await flight.refresh()

console.log(flight.number) // -> "FR 900"
```

## Collections {#id-collections}

As we have seen, the models method `findMany` retrieve multiple records from the database. However, the Athenna model has a `collection` method that will also retrieve
multiple records from the database but return it as an instance of the [`Collection`](/docs/digging-deeper/collections) class.

The Collection class provides a variety of helpful methods for interacting with data collections. For example, the `reject` method may be used to remove models from a
collection based on the results of an invoked closure:

```javascript
const flights = await Flight.collection({ destination: 'Paris' })

const availableFlights = flights.reject(flight => flight.cancelled)
```

## Retrieve single models & Aggregates {#id-retrieve-single-models-and-aggregates}

In addition to retrieving all the records matching a given query, you may also retrieve single records using the `find` method. Instead of returning an array or
collection of models, this method return a single model instance:

```javascript
const flight = await Flight.find({ id: 1 })

const flight = await Flight.find({ active: 1 })

const flight = await Flight.query().where('active', 1).find()
```

Sometimes you may wish to perform some other action if no results are found. The `findOr` method will return a single model instance or, if no results are found,
execute the given closure. The value returned by the closure **will be considered the result of the method:**

```javascript
const flight = await Flight.findOr({ id: 1 }, async () => {
    // ...
})

const flight = await Flight.query()
        .where('legs', '>', 3)
        .findOr(async () => {
            // ...
        })
```

### Not found exceptions {#id-not-found-exceptions}

Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The `findOrFail` method will retrieve
the first result of the query; however, if no result is found, an `ModelNotFoundException` will be thrown:

```javascript
const flight = await Flight.findOrFail({ id: 1 })

const flight = await Flight.query().where('legs', '>', 3).findOrFail()
```

### Retrieving aggregates {#id-retrieving-aggregates}

When interacting with models, you may also use the `count`, `sum`, `max`, and other aggregate methods provided by the [`Athenna query builder`](/docs/database/query-builder).
As you might expect, these methods return a scalar value instead of a model instance:

```javascript
const count = await Flight.query().where('active', 1).count()

const max = await Flight.query().where('active', 1).max('price')
```

:::warning
Aggregate methods will not exist directly in your models, you will always need to call first the `query` method first and then execute it using one of then.
:::
