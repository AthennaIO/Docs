---
sidebar_position: 3

id: relationships
title: Relationships
hide_title: true
hide_table_of_contents: true
tags:
- ORM
- Database
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">ORM</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/orm/relationships">Relationships</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# ORM: Relationships

- #### [Introduction](#id-introduction)
- #### [Defining relationships](#id-defining-relationships)
    - #### [Has One](#id-has-one)
    - #### [Has Many](#id-has-many)
    - #### [Many to Many](#id-many-to-many)
- #### [Querying relationships](#id-querying-relationships)

Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it.
Athenna makes managing and working with these relationships easy, and supports a variety of common relationships:

- [`Has One`](/docs/orm/relationships#id-has-one)
- [`Has Many`](/docs/orm/relationships#id-has-many)
- [`Many to Many`](/docs/orm/relationships#id-one-to-one)

## Defining relationships {#id-defining-relationships}

Athenna relationships are defined in the static `schema` method using the [`Relation`](https://github.com/AthennaIO/Database/blob/develop/src/Relations/Relation.js)
class in your model classes. Let's learn how to define each type of relationship supported by Athenna.

### Has One {#id-has-one}

A one-to-one relationship is a very basic type of database relationship. For example, a `User` model might be associated with one `Phone` model. To define
this relationship, we will place a `phone` property in the `schema` method on the `User` model. The `phone` property should call the `hasOne` method from the
`Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.hasOne(Phone, 'user'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

The first argument passed to the `hasOne` method is the related model class and the second is the inverse side of the relation in the `Phone` class.
Once the relationship is defined, we may retrieve the related record using the `includes` method of the model query builder:

```javascript
const user = await User.query().includes('phone').find()
const phone = user.phone
```

Athenna determines the foreign key of the relationship based on the parent model name. In this case, the `Phone` model is automatically assumed to have a
`userId` foreign key. If you wish to override this convention, you may construct your relation from scratch with the `Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.type('hasOne')
                      .model(Phone)
                      .inverseSide('user')
                      .foreignKey('user_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Additionally, Athenna assumes that the foreign key should have a value matching the primary key column of the parent. In other words, Athenna will look
for the value of the user's `id` column in the `userId` column of the `Phone` record. If you would like the relationship to use a primary key value other
than id or your model's static getter `primaryKey`, you may pass a `primaryKey` method to the `Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.type('hasOne')
                      .model(Phone)
                      .inverseSide('user')
                      .primaryKey('id') // <-
                      .foreignKey('user_id')
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

#### Defining the inverse side of the has one {#id-defining-the-inverse-side-of-the-has-one}

So, we can access the `Phone` model from our `User` model. Next, let's define a relationship on the `Phone` model that will let us access the `user` that
owns the `phone`. We can define the inverse of a `hasOne` relationship using the `belongsTo` method:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.belongsTo(User, 'phone'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

When invoking the `includes` method with the `user` in first param, Athenna will attempt to find a `User` model that has an `id` which matches the `userId`
column on the `Phone` model.

Athenna determines the foreign key name by examining the name of the relationship method and suffixing the method name with `Id`. So, in this case,
Athenna assumes that the `Phone` model has a `userId` column. However, if the foreign key on the `Phone` model is not `userId`, you may build your relation
from scratch to set it:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.type('belongsTo')
                      .model(User)
                      .inverseSide('phone')
                      .foreignKey('phone_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

If the parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a `primaryKey`
method to the `Relation` class:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.type('belongsTo')
                      .model(User)
                      .inverseSide('phone')
                      .primaryKey('id') // <-
                      .foreignKey('phone_id')
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

### Has Many {#id-has-many}

A has many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have
an infinite number of comments. Like all other Athenna ORM relationships, has many relationships are defined by placing the relation property in the `schema`
method:

```javascript
import { Comment } from '#app/Models/Comment'
import { Model, Column, Relation } from '@athenna/database'

export class Post extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      title: Column.string(),
      comments: Relation.hasMany(Comment, 'post'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Remember, Athenna will automatically determine the proper foreign key column for the `Comment` model. By convention, Athenna will take the "camelCase" name
of the parent model and suffix it with `Id`. So, in this example, Athenna will assume the foreign key column on the `Comment` model is `postId`.

Once the relationship property has been defined, we can access the related `comments` by including it with the `includes` method and accessing the
`comments` property:

```javascript
import { Post } from '#app/Models/Post'

const post = await Post.query().includes('comments').find()
const comments = post.comments

comments.forEach(comment => {
    //
})
```

Like the `hasOne` method, you may also override the foreign and local keys by building the relationship from scratch:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      title: Column.string(),
      comments: Relation.type('hasMany')
                      .model(Comment)
                      .inverseSide('post')
                      .primaryKey('id') // <-
                      .foreignKey('post_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

#### Defining the inverse side of the has many {#id-defining-the-inverse-side-of-the-has-many}

Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a
`hasMany` relationship, define a relationship property on the child model `schema` which calls the `belongsTo` method:

```javascript
import { Post } from '#app/Models/Post'
import { Model, Column, Relation } from '@athenna/database'

export class Comment extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.belongsTo(Post, 'comments'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Once the relationship has been defined, we can retrieve a comment's parent post using the `includes` method:

```javascript
import { Comment } from '#app/Models/Comment'

const comment = await Comment.query().includes('post').find()

console.log(comment.post.title)
```

In the example above, Athenna will attempt to find a `Post` model that has an `id` which matches the `postId` column on the `Comment` model.

Athenna determines the default foreign key name by examining the name of the relationship property and suffixing the method name with the name of the
parent model's primary key column in "camelCase" style. So, in this example, Athenna will assume the `Post` model's foreign key on the `comments` table
is `postId`.

However, if the foreign key for your relationship does not follow these conventions, you may create your `belongsTo` relation from scratch:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.type('belongsTo')
                    .model(Post)
                    .inverseSide('comments')
                    .foreignKey('post_id') // <-
                    .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

If your parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may use the `primaryKey` method
in the relation construction:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.type('belongsTo')
                    .model(Post)
                    .inverseSide('comments')
                    .primaryKey('id') // <-
                    .foreignKey('post_id')
                    .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

### Many to Many {#id-many-to-many}

Many-to-many relations are slightly more complicated than `hasOne` and `hasMany` relationships. An example of a many-to-many relationship is a user that
has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of "Author" and "Editor";
however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users.

#### Table structure {#id-table-structure}

To define this relationship, three database tables are needed: `users`, `roles`, and `role_user`. The `role_user` table is derived from the alphabetical
order of the related model names and contains `userId` and `roleId` columns. This table is used as an intermediate table linking the users and roles.

Remember, since a role can belong to many users, we cannot simply place a `userId` column on the `roles` table. This would mean that a role could only
belong to a single user. In order to provide support for roles being assigned to multiple users, the `role_user` table is needed. We can summarize the
relationship's table structure like so:

```
users
    id - integer
    name - string

roles
    id - integer
    name - string

role_user
    userId - integer
    roleId - integer
```

#### Model structure {#id-model-structure}

Many-to-many relationships are defined by writing a property using the `manyToMany` method from `Relation` class. For example, let's define a `roles`
property on our `User` model schema. The first argument passed to this method is the model of the related table and the second argument is the inverse
side of the relation in the `Role` model:

```javascript
import { Role } from '#app/Models/Role'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      roles: Relation.manyToMany(Role, 'users'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Once the relationship is defined, you may access the user's roles using the `includes` method:

```javascript
import { User } from '#app/Models/User'

const user = await User.query().includes('roles').find()
const roles = user.roles

roles.forEach(role => {
    //
})
```

To determine the table name of the relationship's intermediate table, Athenna will join the two related model names in alphabetical order. However, you
are free to override this convention. You may do so by passing a third argument to the `manyToMany` method:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      roles: Relation.manyToMany(Role, 'users', 'users_roles'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by build the many-to-many
relation from scratch. The `pivotLocalForeignKey` method defines the foreign key name of the model on which you are defining the relationship, while the
`pivotRelationForeignKey` method defines the foreign key name of the model that you are joining to:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      roles: Relation.type('manyToMany')
                     .model(Role)
                     .inverseSide('users')
                     .pivotTable('users_roles')
                     .pivotLocalForeignKey('user_id')
                     .pivotRelationForeignKey('role_id')
                     .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

#### Defining the inverse side of the many to many {#id-defining-the-inverse-side-of-the-many-to-many}

To define the "inverse" of a many-to-many relationship, you should define a property on the related model which also returns the result of the `manyToMany`
method. To complete our user / role example, let's define the `users` property on the `Role` model:

```javascript
import { User } from '#app/Models/User'
import { Model, Column, Relation } from '@athenna/database'

export class Role extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      users: Relation.manyToMany(User, 'roles'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

As you can see, the relationship is defined exactly the same as its `User` model counterpart with the exception of referencing the `User` model and a different
inverse side. Since we're reusing the `manyToMany` method, all the usual table and key customization options are available when defining the "inverse" of
many-to-many relationships.

#### Retrieving intermediate table columns {#id-retrieving-intermediate-table-columns}

As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Athenna provides some very helpful ways
of interacting with this table. For example, let's assume our `User` model has many `Role` models that it is related to. After loading the relationship,
using the `includes` method we may access the intermediate table using the `pivot` attribute on the models:

```javascript
import { User } from '#app/Models/User'

const user = await User.query().includes('roles').find()
const roles = user.roles

roles.forEach(role => console.log(role.pivot.createdAt))
```

Notice that each `Role` model we retrieve is automatically assigned a `pivot` attribute. This attribute contains all the data representing the intermediate
table.

## Querying relations {#id-querying-relations}

Coming soon...


