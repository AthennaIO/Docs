---
title: Relationships
sidebar_position: 3
description: See how to create relations between models in Athenna Framework.
---

# ORM: Relationships

See how to create relations between models in Athenna Framework.

## Defining relationships

Database tables are often related to one another. For example, a 
blog post may have many comments or an order could be related to 
the user who placed it. Athenna makes managing and working with 
these relationships easy, and supports a variety of common 
relationships that are defined as properties on your model classes
using annotations:

```typescript
import {
  Column,
  HasOne,
  HasMany,
  BaseModel,
  BelongsTo,
  BelongsToMany,
  type Relation,
} from '@athenna/database'

import { Course } from '#app/models/Course'
import { Profile } from '#app/models/Profile'
import { Comment } from '#app/models/Comment'
import { Customer } from '#app/models/Customer'
import { UsersCourses } from '#app/models/UsersCourses'

export class User extends BaseModel {
  @Column()
  public id: number 

  @HasOne(() => Profile)
  public profile: Relation<Profile> 

  @HasMany(() => Comment)
  public comments: Relation<Comment[]> 

  @BelongsTo(() => Customer)
  public customer: Relation<Customer> 

  @BelongsToMany(() => Course, () => UsersCourses) 
  public courses: Relation<Course[]> 
}
```

:::tip

Check the full documentation of relationships annotations:

- [`@HasOne()`](/docs/orm/annotations#has-one)
- [`@HasMany()`](/docs/orm/annotations#has-many)
- [`@BelongsTo()`](/docs/orm/annotations#belongs-to)
- [`@BelongsToMany()`](/docs/orm/annotations#belongs-to-many)

:::

On this documentation you will see how to setup the following
relationships using the above annotations:

- [One To One](/docs/orm/relationships#one-to-one)
- [One To Many](/docs/orm/relationships#one-to-many)
- [Many To Many](/docs/orm/relationships#many-to-many)

## One To One

A one-to-one relationship is a very basic type of database relationship. 
For example, a `User` model might be associated with one `Phone` model. 
To define this relationship, we will place a `phone` property on the `User` 
model and annotate it with the `@HasOne()` annotation:

```typescript
import { Phone } from '#app/models/Phone'
import type { Relation } from '@athenna/database'
import { Column, BaseModel, HasOne, type Relation } from '@athenna/database'

export class User extends BaseModel {
  @Column()
  public id: number

  @HasOne(() => Phone)
  public phone: Relation<Phone> 
}
```

The first argument passed to the `@HasOne()` annotation is closure
that return the related model class. Once the relationship is defined, 
we may retrieve the related record using the `with()` method of the
model query builder:

```typescript
const { phone } = await User.query()
  .with('phone')
  .find()
```

Since all relationships are extending `BaseModel`, you may add further 
constraints to the relationship query by adding a closure as second argument
of the `with()` method:

```typescript
const { phone } = await User.query()
  .with('phone')
  .find()

// Or

const user = await User.find()

await user.load('phone', query => query.where('ddd', '+55'))

console.log(user.phone)
```

Athenna determines the foreign key of the relationship based on the 
parent model name. In this case, the `Phone` model is automatically 
assumed to have a `userId` foreign key. If you wish to override this 
convention, you may pass a second argument to the `@HasOne()` annotation:

```typescript
@HasOne(() => Phone, { foreignKey: 'foreignKey' })
public phone: Relation<Phone> 
```

Additionally, Athenna assumes that the foreign key should have a 
value matching the primary key column of the parent. In other words, 
Athenna will look for the value of the user's id column in the `userId` 
column of the `Phone` record. If you would like the relationship to 
use a primary key value other than `id`, you may pass a `primaryKey`
property to the options in the second argument:

```typescript
@HasOne(() => Phone, {
  primaryKey: 'primaryKey',
  foreignKey: 'foreignKey'
})
public phone: Relation<Phone> 
```

### Defining the inverse of the relationship

So, we can access the `Phone` model from our `User` model. 
Next, let's define a relationship on the `Phone` model that 
will let us access the user that owns the phone. We can define 
the inverse of a `@HasOne()` relationship using the `@BelongsTo()` 
annotation:

```typescript
import { User } from '#app/models/User'
import type { Relation } from '@athenna/database'
import { Column, BelongsTo, BaseModel } from '@athenna/database'

export class Phone extends BaseModel {
  @Column()
  public id: number

  @Column()
  public userId: number

  @BelongsTo(() => User)
  public user: Relation<User> 
}
```

When invoking the `with('user')` method, Athenna will attempt to find 
a `User` model that has an id which matches the `userId` column on the 
`Phone` model.

Athenna determines the foreign key name by examining the name of the 
relationship model and suffixing it with `Id`. So, in this case, 
Athenna assume that the `Phone` model has a `userId` column. However, 
if the foreign key on the `Phone` model is not `userId`, you may pass 
a custom key name as the second argument to the `@BelongsTo()`
annotation:

```typescript
@BelongsTo(() => User, { foreignKey: 'foreignKey' })
public user: Relation<User> 
```

If the parent model does not use `id` as its primary key, or you wish 
to find the associated model using a different column, you may pass a 
third argument to the `@BelongsTo()` method specifying the parent 
table's custom key:

```typescript
@BelongsTo(() => User, { 
  primaryKey: 'primaryKey',
  foreignKey: 'foreignKey' 
})
public user: Relation<User> 
```

## One To Many

A one-to-many relationship is used to define relationships where a 
single model is the parent to one or more child models. For example, 
a blog post may have an infinite number of comments. Like all other 
Athenna relationships, one-to-many relationships are defined by 
defining a `@HasMany()` annotation in your model class property:

```typescript
import { Comment } from '#app/models/Comment'
import type { Relation } from '@athenna/database'
import { Column, BaseModel, HasMany } from '@athenna/database'

export class Post extends BaseModel {
  @Column()
  public id: number

  @HasMany(() => Comment)
  public comments: Relation<Comment[]> 
}
```

Remember, Athenna will automatically determine the proper foreign 
key column for the `Comment` model. By convention, Athenna will take 
the "camelCase" name of the parent model and suffix it with `Id`. So, 
in this example, Athenna will assume the foreign key column on the 
`Comment` model is `postId`.

Once the relationship method has been defined, we can access the 
data of related `comments` by using the `with()` method: 

```typescript
const { comments } = await Post.query()
  .with('comments')
  .find()
```

Since all relationships are extending `BaseModel`, you may add further 
constraints to the relationship query by adding a closure as second argument
of the `with()` method:

```typescript
const { comments } = await Post.query()
  .with('comments', query => query.where('title', 'foo'))
  .find()

// Or

const post = await Post.find()

await post.load('comments', query => query.where('title', 'foo'))

console.log(post.comments)
```

Like the `@HasOne()` annotation, you may also override the foreign and 
primary keys by passing the additional options second argument to the 
`@HasOne()` annotation:

```typescript
@HasMany(() => Comment, { 
  foreignKey: 'foreignKey',
  primaryKey: 'primaryKey'
})
public comments: Relation<Comment[]>
```

### Defining the inverse of the relationship (Many To One)

Now that we can access all of a post's comments, let's define a 
relationship to allow a comment to access its parent post. To 
define the inverse of a `@HasMany()` relationship, define a 
relationship property on the child model annotated with the 
`@BelongsTo()` annotation:

```typescript
import { Post } from '#app/models/Post'
import type { Relation } from '@athenna/database'
import { Column, BaseModel, BelongsTo } from '@athenna/database'

export class Comment extends BaseModel {
  @Column()
  public id: number

  @Column()
  public postId: number

  @BelongsTo(() => Post)
  public post: Relation<Post> 
}
```

And just like the other relationships, once we have defined it in
our class, we can retrieve a comment's parent post by using the 
`with()` and `load()` methods:

```typescript
const { post } = await Comment.query()
  .with('post', query => query.where('title', 'foo'))
  .find()

// Or

const comment = await Comment.find()

await comment.load('post', query => query.where('title', 'foo'))

console.log(comment.post)
```

In the example above, Athenna will attempt to find a Post model 
that has an id which matches the `postId` column on the Comment model.

Athenna determines the foreign key name by examining the name of the 
relationship model and suffixing it with `Id`. So, in this case, 
Athenna assume that the `Comment` model has a `postId` column. However, 
if the foreign key on the `Comment` model is not `postId`, you may pass 
a custom key name as the second argument to the `@BelongsTo()`
annotation:

```typescript
@BelongsTo(() => Post, { foreignKey: 'foreignKey' })
public post: Relation<Post[]>
```

If your parent model does not use `id` as its primary key, or you 
wish to find the associated model using a different column, you 
may pass a `primaryKey` option specifying your parent table's 
custom key:

```typescript
@BelongsTo(() => Post, {
  foreignKey: 'foreignKey',
  primaryKey: 'primaryKey'
})
public post: Relation<Post[]>
```

## Many To Many

Comming soon...

