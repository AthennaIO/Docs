---
sidebar_position: 3

id: relationships
title: Relationships
hide_title: true
hide_table_of_contents: true
tags:
- ORM
- Database
---

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">ORM</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/orm/relationships">Relationships</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# ORM: Relationships

- #### [Introduction](#id-introduction)
- #### [Defining relationships](#id-defining-relationships)
    - #### [Has One](#id-has-one)
    - #### [Has Many](#id-has-many)
    - #### [Many to Many](#id-many-to-many)

Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it.
Athenna makes managing and working with these relationships easy, and supports a variety of common relationships:

- [`Has One`](/docs/orm/relationships#id-has-one)
- [`Has Many`](/docs/orm/relationships#id-has-many)
- [`Many to Many`](/docs/orm/relationships#id-one-to-one)

## Defining relationships {#id-defining-relationships}

Athenna relationships are defined in the static `schema` method using the [`Relation`](https://github.com/AthennaIO/Database/blob/develop/src/Relations/Relation.js)
class in your model classes. Let's learn how to define each type of relationship supported by Athenna.

### Has One {#id-has-one}

A one-to-one relationship is a very basic type of database relationship. For example, a `User` model might be associated with one `Phone` model. To define
this relationship, we will place a `phone` property in the `schema` method on the `User` model. The `phone` property should call the `hasOne` method from the
`Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.hasOne(Phone, 'user'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

The first argument passed to the `hasOne` method is the related model class and the second is the inverse side of the relation in the `Phone` class.
Once the relationship is defined, we may retrieve the related record using the `includes` method of the model query builder:

```javascript
const user = await User.query().includes('phone').find()
const phone = user.phone
```

Athenna determines the foreign key of the relationship based on the parent model name. In this case, the `Phone` model is automatically assumed to have a
`userId` foreign key. If you wish to override this convention, you may construct your relation from scratch with the `Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.type('hasOne')
                      .model(Phone)
                      .inverseSide('user')
                      .foreignKey('user_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Additionally, Athenna assumes that the foreign key should have a value matching the primary key column of the parent. In other words, Athenna will look
for the value of the user's `id` column in the `userId` column of the `Phone` record. If you would like the relationship to use a primary key value other
than id or your model's static getter `primaryKey`, you may pass a `primaryKey` method to the `Relation` class:

```javascript
import { Phone } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class User extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      name: Column.string(),
      phoneId: Column.integer('phone_id'),
      phone: Relation.type('hasOne')
                      .model(Phone)
                      .inverseSide('user')
                      .primaryKey('id') // <-
                      .foreignKey('user_id')
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

#### Defining the inverse side of the has one {#id-defining-the-inverse-side-of-the-has-one}

So, we can access the `Phone` model from our `User` model. Next, let's define a relationship on the `Phone` model that will let us access the `user` that
owns the `phone`. We can define the inverse of a `hasOne` relationship using the `belongsTo` method:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.belongsTo(User, 'phone'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

When invoking the `includes` method with the `user` in first param, Athenna will attempt to find a `User` model that has an `id` which matches the `userId`
column on the `Phone` model.

Athenna determines the foreign key name by examining the name of the relationship method and suffixing the method name with `Id`. So, in this case,
Athenna assumes that the `Phone` model has a `userId` column. However, if the foreign key on the `Phone` model is not `userId`, you may build your relation
from scratch to set it:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.type('belongsTo')
                      .model(User)
                      .inverseSide('phone')
                      .foreignKey('phone_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

If the parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a `primaryKey`
method to the `Relation` class:

```javascript
import { User } from '#app/Models/Phone'
import { Model, Column, Relation } from '@athenna/database'

export class Phone extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      number: Column.string(),
      userId: Column.integer('user_id'),
      user: Relation.type('belongsTo')
                      .model(User)
                      .inverseSide('phone')
                      .primaryKey('id') // <-
                      .foreignKey('phone_id')
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

### Has Many {#id-has-many}

A has many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have
an infinite number of comments. Like all other Athenna ORM relationships, has many relationships are defined by placing the relation property in the `schema`
method:

```javascript
import { Comment } from '#app/Models/Comment'
import { Model, Column, Relation } from '@athenna/database'

export class Post extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      title: Column.string(),
      comments: Relation.hasMany(Comment, 'post'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Remember, Athenna will automatically determine the proper foreign key column for the `Comment` model. By convention, Athenna will take the "camelCase" name
of the parent model and suffix it with `Id`. So, in this example, Athenna will assume the foreign key column on the `Comment` model is `postId`.

Once the relationship property has been defined, we can access the related `comments` by including it with the `includes` method and accessing the
`comments` property:

```javascript
import { Post } from '#app/Models/Post'

const post = await Post.query().includes('comments').find()
const comments = post.comments

comments.forEach(comment => {
    //
})
```

Like the `hasOne` method, you may also override the foreign and local keys by building the relationship from scratch:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      title: Column.string(),
      comments: Relation.type('hasMany')
                      .model(Comment)
                      .inverseSide('post')
                      .primaryKey('id') // <-
                      .foreignKey('post_id') // <-
                      .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

#### Defining the inverse side of the has many {#id-defining-the-inverse-side-of-the-has-many}

Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a
`hasMany` relationship, define a relationship property on the child model `schema` which calls the `belongsTo` method:

```javascript
import { Post } from '#app/Models/Post'
import { Model, Column, Relation } from '@athenna/database'

export class Comment extends Model {
  static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.belongsTo(Post, 'comments'),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
  }

  /*...*/
}
```

Once the relationship has been defined, we can retrieve a comment's parent post using the `includes` method:

```javascript
import { Comment } from '#app/Models/Comment'

const comment = await Comment.query().includes('post').find()

console.log(comment.post.title)
```

In the example above, Athenna will attempt to find a `Post` model that has an `id` which matches the `postId` column on the `Comment` model.

Athenna determines the default foreign key name by examining the name of the relationship property and suffixing the method name with the name of the
parent model's primary key column in "camelCase" style. So, in this example, Athenna will assume the `Post` model's foreign key on the `comments` table
is `postId`.

However, if the foreign key for your relationship does not follow these conventions, you may create your `belongsTo` relation from scratch:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.type('belongsTo')
                    .model(Post)
                    .inverseSide('comments')
                    .foreignKey('post_id') // <-
                    .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

If your parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may use the `primaryKey` method
in the relation construction:

```javascript
static schema() {
    return {
      id: Column.autoIncrementedInt(),
      content: Column.string(),
      postId: Column.string(),
      post: Relation.type('belongsTo')
                    .model(Post)
                    .inverseSide('comments')
                    .primaryKey('id') // <-
                    .foreignKey('post_id')
                    .get(),
      createdAt: Column.createdAt(),
      updatedAt: Column.updatedAt(),
      deletedAt: Column.deletedAt(),
    }
}
```

### Many to Many {#id-many-to-many}

Coming soon...

