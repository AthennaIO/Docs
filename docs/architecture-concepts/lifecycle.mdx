---
sidebar_position: 1

id: lifecycle
title: Application Lifecycle
hide_title: true
hide_table_of_contents: true
tags:
- Architecture Concepts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ThemedImage from '@theme/ThemedImage';
import useBaseUrl from "@docusaurus/useBaseUrl";

<nav aria-label="breadcrumbs">
    <ul class="breadcrumbs">
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/">üè†</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link">Architecture Concepts</a>
        </li>
        <li class="breadcrumbs__item">
            <a class="breadcrumbs__link" href="/docs/architecture-concepts/lifecycle">Application Lifecycle</a>
        </li>
    </ul>
</nav>

<span class="badge badge--secondary margin-top-bot">version 1.0.0</span>

# Application Lifecycle

- #### [Introduction](#id-introduction)
- #### [Lifecycle overview](#id-lifecycle-overview)
  - #### [First steps](#id-first-steps)
  - #### [Service providers](#id-service-providers)
  - #### [Kernels](#id-kernels)
  - #### [Routes](#id-routes)
  - #### [Finishing up](#id-finishing-up)
- #### [Focus on service providers](#id-focus-on-service-providers)

## Introduction {#id-introduction}

When using any tool in the "real world", you feel more confident if you understand how that tool works. Application
development is no different. When you understand how your development tools function, you feel more comfortable and
confident using them.

The goal of this document is to give you a good, high-level overview of how the Athenna framework works. By getting to
know the overall framework better, everything feels less "magical" and you will be more confident building your
applications. If you don't understand all the terms right away, don't lose heart! Just try to get a basic grasp of what
is going on, and your knowledge will grow as you explore other sections of the documentation.

## Lifecycle overview {#id-lifecycle-overview}

### First steps {#id-first-steps}

The entry point for all types of an Athenna application is the `bootstrap/main` file. The first action taken by Athenna
itself is to create an instance of the application and then boot it.

:::info

Athenna has the class called `Ignite`. This class is responsible for resolving your environment, your language type (ts, js),
resolving your environment files and configuration files of `config` folder and booting/registering your providers. In the
end of all, `fire` method returns a new `Application` instance, and it's with this instance that we are going to choose
what type of application we want to run (http, worker, cli, etc...).

:::

### Service providers {#id-service-providers}

One of the most important kernel bootstrapping actions is loading the service providers for your application. All the
service providers for the application are configured in the `config/app` configuration file's providers array.

Athenna will iterate through this list of providers and instantiate each of them. After instantiating the providers,
the `register` method will be called on all the providers. Then, once all the providers have been registered, the
`boot` method will be called on each provider. This is so service providers may depend on every container binding being
registered and available by the time their boot method is executed.

Service providers are responsible for bootstrapping all the framework's various components, such as the database, http server,
validation, services and routing components. Essentially every major feature offered by Athenna is bootstrapped and
configured by a service provider. Since they bootstrap and configure so many features offered by the framework, service
providers are the most important aspect of the entire Athenna bootstrap process.

### Kernels {#id-kernels}

Each Athenna application type have a `Kernel`. This classes serves configurations for each type of application.

<Tabs>
<TabItem value="Http Kernel" label="Http Kernel" default>

The Kernel of `Http` folder extends the `HttpKernel` class from `@athenna/http`, which defines some bootstraps that will
be run before the `routes/http` file is preloaded. These bootstraps configure error handling, configure logging, detect
the application environment, and perform other tasks that need to be done before the request is actually handled. Typically,
these classes handle internal Athenna configuration that you do not need to worry about.

The Kernel of `Http` folder also defines a list of global [`middlewares`](/docs/the-basics/http/middlewares) that all requests must pass through before being
handled by the application. It also defines your named middlewares to use inside `routes/http` file. See the example:

```javascript
/**
* The application's global HTTP middlewares.
*
* This middlewares are run during every request to your http server.
*/
globalMiddlewares = [import('#app/Http/Middlewares/ResponseMiddleware')]
```

Or you can define as a named middleware and choose what routes are going to use it inside `routes/http`:

```javascript
/**
* The application's named HTTP middlewares.
*
* Here you define all your named middlewares to use inside routes/http file.
*/
namedMiddlewares = {
    response: import('#app/Http/Middlewares/ResponseMiddleware')
}
```

```javascript
Route.get('/', 'WelcomeController.show').middleware('response')
```

</TabItem>
<TabItem value="Console Kernel" label="Console Kernel">

The Kernel of `Console` folder extends the `ConsoleKernel` class from `@athenna/artisan`, which defines some bootstraps that will
be run before the `routes/console` file is preloaded. These bootstraps configure error handling, configure logging, detect
the application environment, and perform other tasks that need to be done before the request is actually handled. Typically,
these classes handle internal Athenna configuration that you do not need to worry about.

The Kernel of `Console` folder also defines a list of [`commands`](/docs/the-basics/cli/commands) that will be registered
before the application bootstrap and before preloading `routes/console`. See the example:

```typescript
/**
* The application's global HTTP middlewares.
*
* This middlewares are run during every request to your http server.
*/
protected commands = [
  import('@athenna/artisan/src/Commands/Eslint/Fix'),
  import('@athenna/artisan/src/Commands/Make/Facade'),
  import('@athenna/artisan/src/Commands/Make/Command'),
  import('@athenna/artisan/src/Commands/Make/Service'),
  import('@athenna/artisan/src/Commands/Make/Provider'),
  import('@athenna/artisan/src/Commands/Make/Controller'),
  import('@athenna/artisan/src/Commands/Make/Middleware'),
  import('App/Console/Commands/MyNewCommand'),
]
```

</TabItem>
</Tabs>

### Routes {#id-routes}

The `routes` folder is the kernel of your application. The route files that you will find here are:

<Tabs>
<TabItem value="http" label="http" default>

This file is responsible to create a contract between your client and your application. Is
in here that we define all of ours routes and the controllers who will handle the client request.

One of the most important service providers in your application is the `HttpRouteProvider`. This service provider adds in
the container the `Route` class instance used inside `http` file.

When the client request arrives, the server first execute all `handle` method of your global middlewares. Than it will execute
the `handle` method of all your route middlewares. Once it finish, it goes for your controller or handler function. See the example:

<ThemedImage
    alt="Handle request image"
    sources={{
        light: useBaseUrl('/img/handle-request-1-light.png'),
        dark: useBaseUrl('/img/handle-request-1-dark.png'),
    }}
/>

</TabItem>
<TabItem value="console" label="console">

This file is responsible to create a contract between your client and your application. Is in here that we define some
of ours commands and their handlers.

One of the most important service providers in your application is the `ArtisanProvider`. This service provider adds in
the container the `Artisan` class instance used inside `console` file.

When console commands arrive, the Artisan will take all the arguments sent by the client and send to [`commander`](https://www.npmjs.com/package/commander)
to resolve the command. Then commander will execute the `handler` defined by your command. See the example:

<ThemedImage
    alt="Handle console image"
    sources={{
        light: useBaseUrl('/img/handle-console-1-light.png'),
        dark: useBaseUrl('/img/handle-console-1-dark.png'),
    }}
/>

</TabItem>
</Tabs>

### Finishing up {#id-finishing-up}

<Tabs>
<TabItem value="http" label="http" default>

Once the controller/handler function returns a response, the response will travel back outward through the `intercept`
method of each global middleware and than route's middleware, giving the application a chance to modify or examine the
outgoing response. See the example:

<ThemedImage
    alt="Handle request image"
    sources={{
        light: useBaseUrl('/img/handle-request-2-light.png'),
        dark: useBaseUrl('/img/handle-request-2-dark.png'),
    }}
/>

As you can see in the example the response content is sent to the client. The request finish for the client but not for
the server. Now it's time to execute the `terminate` method from our global and route's middleware. The `terminate` method
is executed when a response has been sent, so you will not be able to send more data to the client. It can however be
useful for sending data to external services, for example, create metrics of the entire request. See the example:

<ThemedImage
    alt="Handle request image"
    sources={{
        light: useBaseUrl('/img/handle-request-3-light.png'),
        dark: useBaseUrl('/img/handle-request-3-dark.png'),
    }}
/>

Finally, once the `terminate` method is executed in all middlewares the request finish in the server. We've finished
our journey through the entire Athenna request lifecycle!

</TabItem>
<TabItem value="cli" label="cli">

That's all the flow of calling a command inside Athenna using Artisan. It's very simple, the application starts, runs and
goes down.

<ThemedImage
    alt="Handle console image"
    sources={{
        light: useBaseUrl('/img/handle-console-1-light.png'),
        dark: useBaseUrl('/img/handle-console-1-dark.png'),
    }}
/>

We've finished our journey through the entire Athenna console command lifecycle!

</TabItem>
</Tabs>

## Focus on service providers {#id-focus-on-service-providers}

Service providers are truly the key to bootstrapping an Athenna application. The application instance is created, the
service providers are registered, and the request is handed to the bootstrapped application. It's really that simple!

Having a firm grasp of how an Athenna application is built and bootstrapped via service providers is very valuable.
Your application's default service providers are stored in the `providers` directory.

By default, the `AppServiceProvider` is fairly empty. This provider is a great place to add your application's own
bootstrapping and service container bindings. For large applications, you may wish to create several service providers,
each with more granular bootstrapping for specific services used by your application.
