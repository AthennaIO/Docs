---
title: Commands
sidebar_position: 1
description: See how to create and configure your CLI commands.
tags:
  - CLI Application
  - Commands
---

import ReactPlayer from 'react-player'

# Commands

See how to create and configure your CLI commands.

## Introduction

In Athenna you are able to create your own CLI application
creating your own commands by extending the abstract class
`Command` and implement its methods.

## Writing commands

In addition to the commands provided with Artisan, you may
build your own custom commands. Commands are typically stored
in the `app/console/commands` directory; however, you are
free to choose your own storage location as long as your
commands can be imported.

## Registering commands

All of your console commands are registered within your
application's `.athennarc.json` file. If you have created
your command using `make:command` your command will already
be registered for you in `commands` object, but we still
recommend you to do some adjustments before using your
command.

In the example above we have changed the signature of
`SendEmails` command to `send:email`, we should always
use the command `signature` as key when registering our
commands in `commands` object:

```json
{
  "commands": {
    "send:email": { üëà
      "path": "#app/console/commands/SendEmails",
      "loadApp": true
    }
  }
}
```

If you do so, Athenna will always import and load only that
specific command that you want to execute, meaning that if
you execute the following command:

```shell
./node artisan send:email lenon@athenna.io
```

Athenna will only import and load `SendEmails` class and
execute your command. If you change the key name to any
value different from the command `signature` (`send:email`)
Athenna will load all your commands defined in `commands`
object:

```json
{
  "commands": {
    "sendEmails": { üëà // All commands will be loaded
      "path": "#app/console/commands/SendEmails",
      "loadApp": true
    }
  }
}
```

Loading all commands might be useful sometimes when your
command wants to [execute other commands in runtime](#calling-commands-in-runtime)
inside your command:

```typescript
import { Inject } from '@athenna/ioc'
import { MailgunService } from '#app/services/MailgunService'
import { Option, Artisan, Argument, BaseCommand } from '@athenna/artisan'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Argument()
  private email: string

  @Option({
    signature: '-s, --subject <subject>',
    default: 'Athenna',
    description: 'Set the subject of the email.',
  })
  private subject: string

  @Inject()
  private mailgunService: MailgunService

  public async handle(): Promise<void> {
    const message = 'Hello from Athenna!'

    await this.mailgunService.send(this.email, {
      message,
      subject: this.subject,
    })

    await Artisan.call(`save:email ${this.email}`)
  }
}
```

:::tip

Even for this purpose, we recommend you to let the key
of your command the same of your command `signature`.
To load all your commands, use the `loadAllCommands`
setting in your command:

```json
{
  "commands": {
    "send:email": {
      "path": "#app/console/commands/SendEmails",
      "loadApp": true,
      "loadAllCommands": true üëà // All commands will be loaded
    }
  }
}
```

:::

## Generating commands

To create a new command, you may use the `make:command`
Artisan command. This command will create a new command
class in the `app/console/commands` directory and register
it inside `commands` object of `.athennarc.json` file.
Don't worry if this directory does not exist in your
application‚Äîit will be created the first time you run the
`make:command` Artisan command:

```shell
./node artisan make:command SendEmails
```

## Commands structure

Athenna commands are represented as classes and always extend 
the `BaseCommand` class. You define the command `signature` and 
`description` as static properties on the class itself:

```typescript
export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'sendEmails'
  }

  public static description(): string {
      return 'The description of sendEmails command'
  }

  public async handle(): Promise<void> {
    //
  }
}
```

- `signature` - The signature is basicaly the command. You will
always use this signature to call your command in terminal. It 
should always be a string.
- `description` - The description is a short description of what
your command does, it will always be displayed in the help output.
- `handle` - The handle method will contain the logic of your 
command, this method will be called when executing your command.

### Booting the app within the command

Artisan commands do not boot your application before running 
the command. If your command relies on the application code, 
you must instruct the command to load the application first 
and then execute the `handle` method:

```json title=".athennarc.json"
{
  "commands": {
    "sendEmails": {
      "path": "#app/console/commands/SendEmails",
      "loadApp": true üëà
    }
  }
}
```

Now we are able to request any dependencies we need using
the `@Inject()` annotation:

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Inject()
  private mailgunService: MailgunService üëà

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

### Constructor injection is not allowed

The application is bootstrapped only after your command is
already registered, meaning that you can't use the
automatic constructor injection with commands to resolve
your dependencies:

#### ‚ùå Does not work

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  public constructor(private mailgunService: MailgunService) { üëà
    super()
  }

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

#### ‚úÖ Works

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Inject()
  private mailgunService: MailgunService üëà

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

:::tip

For greater code reuse, it is good practice keeping your
console commands light and let them defer to application
services to accomplish their tasks. In the example above,
note that we inject a service class to do the "heavy
lifting" of sending the e-mails.

:::

## Calling commands in runtime

Sometimes you may wish to call other commands from an
existing Artisan command or from any other part of your
application. You may do so using the `call()` method from
Artisan. This method accepts the command string with its
arguments and options:

```typescript
import { Artisan } from '@athenna/artisan'

await Artisan.call('make:controller TestController')
```

If you want to verify if your command has generated some
output in `stdout` or `stderr` you can use the
`callInChild()` method:

```typescript
const { stdout, stderr } = await Artisan.callInChild('make:controller TestController')

assert.isTrue(stdout.includes('[ MAKING CONTROLLER ]'))
assert.isUndefined(stderr)
```

By default this method will look to the `Path.boostrap('artisan.ts')`
file to execute your command, but you can change the file to be used
setting the path to it as second parameter:

```typescript
const command = 'make:controller TestController'
const artisanPath = Path.pwd(`artisan.${Path.ext()}`)

await Artisan.callInChild(command, artisanPath)
```

## Defining input expectations

When writing console commands, it is common to gather
input from the user through arguments or options. Athenna
makes it very convenient to define the input you expect
from the user using the `@Argument()` and `@Option()`
annotations on your commands. See the example:

```typescript
import { Inject } from '@athenna/ioc'
import { MailgunService } from '#app/services/MailgunService'
import { Option, Argument, BaseCommand } from '@athenna/artisan'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Argument()
  private email: string

  @Option({
    signature: '-s, --subject <subject>',
    default: 'Athenna',
    description: 'Set the subject of the email.',
  })
  private subject: string

  @Inject()
  private mailgunService: MailgunService

  public async handle(): Promise<void> {
    const message = 'Hello from Athenna!'

    await this.mailgunService.send(this.email, {
      message,
      subject: this.subject,
    })
  }
}
```

### Arguments

Command arguments are positional, and they are accepted 
in the same order as you define them in your class. 
For example:

```typescript
import { Argument, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Argument()
  public name: string

  @Argument()
  public age: string
}
```

```shell
./node artisan greet <name> <age>
```

#### Spread/Variadic arguments

The `@Argument()` annotation allows you to define a 
catch-all argument. It is like the rest parameters 
in JavaScript and must always be the last argument:

```typescript
import { Argument, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Argument()
  public age: string

  @Argument({ signature: '<names...>' }) üëà
  public names: string[] üëà

  public async handle() {
    console.log(this.age, this.names)
  }
}
```

```shell
./node artisan greet 22 lenon txsoura
```

Will output:

```typescript
22 [ 'lenon', 'txsoura' ]
```

#### Arguments options

The `@Argument()` annotation accept the following options:

- `signature` - The signature of the argument. If not present
the name of the class property will be used.
- `description` - The description of the argument. This will
be displayed in the help output.
- `required` - Set if the argument is required or not. This
could also be done in the `signature` using `<argName>` for 
required and `[argName]` for optional.

### Options

You define the options using the `@Option()` annotation:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Option({ signature: '-n, --name <name>' })
  public name: string

  public async handle() {
    console.log('hey', this.name)
  }
}
```

```shell
./node artisan greet -n lenon
```

Will output:

```typescript
hey lenon
```

#### Negatable boolean options

You can define a boolean option long name with a 
leading `no-` to set the option value to `false` 
when used. Defined alone this also makes the option 
`true` by default.

If you define `--foo` first, adding `--no-foo` does 
not change the default value from what it would otherwise be:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class AthennaPizzeria extends BaseCommand {
  public static signature(): string {
    return 'pizza'
  }

  @Option({ signature: '--no-sauce' })
  public addSauce: boolean

  @Option({ signature: '--cheese <flavour>' })
  public cheeseFlavour: string

  @Option({ signature: '--no-cheese' })
  public addCheese: boolean

  public async handle() {
    const sauceStr = this.addSauce ? 'sauce' : 'no sauce'
    const cheeseStr = (this.addCheese === false) ? 'no cheese' : `${this.chesseFlavour} cheese`;

    console.log(`You ordered a pizza with ${sauceStr} and ${cheeseStr}`);
  }
}
```

```shell
./node artisan pizza
You ordered a pizza with sauce and mozzarella cheese

./node artisan pizza --sauce
error: unknown option '--sauce'

./node artisan pizza --cheese=blue
You ordered a pizza with sauce and blue cheese

./node artisan pizza --no-sauce --no-cheese
You ordered a pizza with no sauce and no cheese
```

#### Spread/Variadic options

The `@Argument()` annotation allows you to define a 
catch-all argument. It is like the rest parameters 
in JavaScript and must always be the last argument:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Option({ signature: '--names <names...>' }) üëà
  public names: string[] üëà

  public async handle() {
    console.log(this.names)
  }
}
```

```shell
./node artisan greet --names=lenon --names=txsoura
```

Will output:

```typescript
[ 'lenon', 'txsoura' ]
```

#### Option options

The `@Option()` annotation accept the following options:

- `signature` - The signature of the option. If not present
the name of the class property will be used.
- `description` - The description of the option. This will
be displayed in the help output.
- `default` - Set the default value for the option if not 
present.

## Prompts

Artisan has support for creating interactive 
prompts on the terminal thanks to 
[inquirer](https://www.npmjs.com/package/inquirer). 
You can access the prompts 
module using the `this.prompt` property.

In the example below, we are using multiple prompts 
together:

```typescript
import { BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  public async handle() {
    const name = await this.prompt.input('What is your name?')
    const password = await this.prompt.secret('What is your password?')
    const isRobot = await this.prompt.confirm('Are you a robot?')
    const code = await this.prompt.editor('Write a hello world code')
    const card = await this.prompt.list('Select your card type', [
      'debit',
      'credit',
    ])
    const roles = await this.prompt.checkbox('Select the roles', [
      'customer',
      'admin',
    ])

    console.log()

    this.logger.success('Information successfully collected:')
    this.logger
      .table()
      .head('Names', 'Password', 'Is Robot?', 'Code', 'Card', 'Roles')
      .row([name, password, `${isRobot}`, code, card, roles.join(', ')])
      .render()
  }
}
```

<ReactPlayer 
  playing 
  controls
  className='react-player-center'
  url='/videos/prompt-example.mp4' 
/>

##### `this.prompt.input()`

Displays the prompt to enter a input value. 
Optionally accepts [options](https://www.npmjs.com/package/inquirer#question) 
as the **second argument**:

```typescript
await this.prompt.input('What is your name?', {
  validate(input: string) {
    if (!input || input.length < 2) {
      return 'Name is required and must be over 2 characters'
    }

    return true
  },
})
```

#### `this.prompt.secret()`

Same as `input()` but hide what the user is typing. 
Optionally accepts 
[options](https://www.npmjs.com/package/inquirer#question) 
as the **second argument**:

```typescript
await this.prompt.secret('What is your password?', {
  validate(input: string) {
    if (!input || input.length < 2) {
      return 'Password is required and must be over 2 characters'
    }

    return true
  },
})
```

#### `this.prompt.confirm()`

Display the prompt to select between **Yes** and 
**No**. Optionally 
accepts [options](https://www.npmjs.com/package/inquirer#question) 
as the **second argument**:

```typescript
await this.prompt.confirm('Are you a robot?')
```

#### `this.prompt.editor()`

Open a code editor to write a bigger message, 
usually code. Optionally accepts 
[options](https://www.npmjs.com/package/inquirer#question) 
as the **second argument**:

```typescript
await this.prompt.editor('Write a hello world code in Python')
```

#### `this.prompt.list()`

Display a list of options with the possibility to choose 
only one. Optionally accepts 
[options](https://www.npmjs.com/package/inquirer#question) 
as the **third argument**:

```typescript
await this.prompt.list('Select your registry', ['npm', 'pnpm', 'yarn'])
```

#### `this.prompt.checkbox()`

Display a list of options with the possibility to choose 
multiple. Optionally accepts 
[options](https://www.npmjs.com/package/inquirer#question) 
as the **third argument**:

```typescript
await this.prompt.checkbox('Select your dependencies', [
  '@athenna/core', '@athenna/artisan', '@athenna/http'
])
```

## Logger and UI

You can make use of the inbuilt logger to log messages 
to the console using the `this.logger` property. Artisan
logger extends the [`Logger`](/docs/the-basics/logging) 
class from `@athenna/logger`, but it also adds some new 
methods to it: 

```typescript
import { Exec } from '@athenna/common'
import { BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  public async handle() {
    this.logger.simple('({ green, bold }) Hello ({ yellow, bold, italic }) World!')

    this.logger.update('Hey!!')
    await Exec.sleep(1000)
    this.logger.update('How you doing?')

    this.logger.rainbow('Athenna Framework')

    const spinner = this.logger.spinner('Loading unicorns')

    spinner.start()

    setTimeout(() => {
      spinner.color = 'yellow'
      spinner.text = 'Loading rainbows'
    }, 1000)

    await this.logger.promiseSpinner(Exec.sleep(2000), {
      text: 'Loading',
      successText: 'Success!',
      failText: 'Failed!',
    })

    this.logger
      .table()
      .head('HEAD 1', 'HEAD 2')
      .row(['VALUE 1', 'VALUE 2'])
      .row(['VALUE 1', 'VALUE 2'])
      .render()

    const data = {
      'commander@0.6.1': 1,
      'minimatch@0.2.14': 3,
      'mkdirp@0.3.5': 2,
      'sigmund@1.0.0': 3,
    }

    this.logger.column(data, { columns: ['MODULE', 'COUNT'] })

    const path = 'app/services/Service.ts'
    const action = this.logger.action('create')

    action.succeeded(path)
    action.skipped(path, 'File already exists')
    action.failed(path, 'Something went wrong')

    this.logger
      .instruction()
      .head('Project Created')
      .add(`cd ${this.paint.cyan('hello-world')}`)
      .add(`Run ${this.paint.cyan('./node artisan --watch serve')}`)
      .render()

    this.logger
      .sticker()
      .head('Athenna Framework')
      .add('Follow us on Instagram: @athenna.io üç∑')
      .render()

    await this.logger
      .task()
      .add('First task', async task => {
        await Exec.sleep(1000)
        await task.complete('Completed!')
      })
      .add('Second task', async task => {
        await Exec.sleep(1000)
        await task.fail('Failed!')
      })
      .run()
  }
}
```

<ReactPlayer 
  playing 
  controls
  className='react-player-center'
  url='/videos/loggerui-example.mp4' 
/>

#### `this.logger.simple()`

Works like `console.log()`, but automatically handles
the [color engine](/docs/the-basics/helpers#colorapply):

```typescript
this.logger.simple('({ green, bold }) Hello ({ yellow, bold, italic }) World!')
```

#### `this.logger.update()`

Works like [`this.logger.simple()`](/docs/cli-application/commands#thisloggersimple),
but if you call the method multiple times, 
it will always update the message instead
of printing a new one:

```typescript
import { Exec } from '@athenna/common' 

this.logger.update('Hey!!')

await Exec.sleep(1000)

this.logger.update('How you doing?')
```

#### `this.logger.rainbow()`

Print a message with all the colors of the 
rainbow and with [FIGfont](https://github.com/lukesampson/figlet/blob/master/figfont.txt):

```typescript
this.logger.rainbow('Hello World!')
```

#### `this.logger.spinner()`

Creates a spinner to show a loading message.
Very useful when running something in background
and you want to give some feedback for your user:

```typescript
const spinner = this.logger.spinner('Loading unicorns')

spinner.start()

setTimeout(() => {
  spinner.color = 'yellow'
  spinner.text = 'Loading rainbows'
}, 1000)
```

#### `this.logger.promiseSpinner()`

Creates a spinner from a promise. If the promisse
resolves show the `successText`, if fails, the `failText`,
keep running the spinner until the task is running:

```typescript
import { Exec } from '@athenna/common'

await this.logger.promiseSpinner(Exec.sleep(2000), {
  text: 'Loading',
  successText: 'Success!',
  failText: 'Failed!',
})
```

#### `this.logger.table()`

Create text-based table suitable for console 
output. To render the table you need to call 
the `render()` method at the end:

```typescript
const table = this.logger.table()

this.logger.head('HEAD 1', 'HEAD 2')

this.logger.row(['VALUE 1', 'VALUE 2'])
this.logger.row(['VALUE 1', 'VALUE 2'])

this.logger.render()
```

#### `this.logger.column()`

Create text-based columns suitable for 
console output from objects or arrays 
of objects:

```typescript
const data = {
  'commander@0.6.1': 1,
  'minimatch@0.2.14': 3,
  'mkdirp@0.3.5': 2,
  'sigmund@1.0.0': 3,
}

this.logger.column(data, { columns: ['MODULE', 'COUNT'] })
```

#### `this.logger.action()`

Log an action that is happening. Actions has three states
**succeeded**, **skipped** and **failed**. You can use 
actions to explain to the user what happened to some 
determined operation:

```typescript
const path = 'app/services/Service.ts'
const action = this.logger.action('create')

action.succeeded(path)
action.skipped(path, 'File already exists')
action.failed(path, 'Something went wrong')
```

#### `this.logger.instruction()`

Use to display instructions for a given action
by rendering them inside a box:

```typescript
const instruction = this.logger.instruction()

instruction.head('Project Created')

instruction.add(`cd ${this.paint.cyan('hello-world')}`)
instruction.add(`Run ${this.paint.cyan('./node artisan --watch serve')}`)
  
instruction.render()
```

#### `this.logger.sticker()`

Use to display stickers for a given 
action by rendering them inside a box. 
Stickers have the same API of 
[`this.logger.instructions()`](/docs/cli-application/commands#thisloggerinstructions), 
but the rows will not have the icon in front:

```typescript
const sticker = this.logger.sticker()

sticker.head('Athenna Framework')
sticket.add('Follow us on Instagram: @athenna.io üç∑')

sticker.render()
```

#### `this.logger.task()`

Create a task runner that will log the 
status of each task. The task
method is very useful when you need to 
do a lot of tasks in order, giving a status 
to all the tasks and how much time it has 
taken to execute:

```typescript
import { Exec } from '@athenna/common'

const task = this.logger.task()

task.add('First task', async task => {
  await Exec.sleep(1000)
  await task.complete('Completed!')
})

task.add('Second task', async task => {
  await Exec.sleep(1000)
  await task.fail('Failed!')
})

await task.run()
```

## Generating templates in commands

Coming soon

## Manipulating `.athennarc.json` in commands

Coming soon
