---
title: Commands
sidebar_position: 1
description: See how to create and configure your CLI commands.
tags:
  - CLI Application
  - Commands
---

# Commands

See how to create and configure your CLI commands.

## Introduction

In Athenna you are able to create your own CLI application
creating your own commands by extending the abstract class
`Command` and implement its methods.

## Writing commands

In addition to the commands provided with Artisan, you may
build your own custom commands. Commands are typically stored
in the `app/console/commands` directory; however, you are
free to choose your own storage location as long as your
commands can be imported.

## Registering commands

All of your console commands are registered within your
application's `.athennarc.json` file. If you have created
your command using `make:command` your command will already
be registered for you in `commands` object, but we still
recommend you to do some adjustments before using your
command.

In the example above we have changed the signature of
`SendEmails` command to `send:email`, we should always
use the command `signature` as key when registering our
commands in `commands` object:

```json
{
  "commands": {
    "send:email": { üëà
      "path": "#app/console/commands/SendEmails",
      "loadApp": true
    }
  }
}
```

If you do so, Athenna will always import and load only that
specific command that you want to execute, meaning that if
you execute the following command:

```shell
./node artisan send:email lenon@athenna.io
```

Athenna will only import and load `SendEmails` class and
execute your command. If you change the key name to any
value different from the command `signature` (`send:email`)
Athenna will load all your commands defined in `commands`
object:

```json
{
  "commands": {
    "sendEmails": { üëà // All commands will be loaded
      "path": "#app/console/commands/SendEmails",
      "loadApp": true
    }
  }
}
```

Loading all commands might be useful sometimes when your
command wants to [execute other commands in runtime](#calling-commands-in-runtime)
inside your command:

```typescript
import { Inject } from '@athenna/ioc'
import { MailgunService } from '#app/services/MailgunService'
import { Option, Artisan, Argument, BaseCommand } from '@athenna/artisan'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Argument()
  private email: string

  @Option({
    signature: '-s, --subject <subject>',
    default: 'Athenna',
    description: 'Set the subject of the email.',
  })
  private subject: string

  @Inject()
  private mailgunService: MailgunService

  public async handle(): Promise<void> {
    const message = 'Hello from Athenna!'

    await this.mailgunService.send(this.email, {
      message,
      subject: this.subject,
    })

    await Artisan.call(`save:email ${this.email}`)
  }
}
```

:::tip

Even for this purpose, we recommend you to let the key
of your command the same of your command `signature`.
To load all your commands, use the `loadAllCommands`
setting in your command:

```json
{
  "commands": {
    "send:email": {
      "path": "#app/console/commands/SendEmails",
      "loadApp": true,
      "loadAllCommands": true üëà // All commands will be loaded
    }
  }
}
```

:::

## Generating commands

To create a new command, you may use the `make:command`
Artisan command. This command will create a new command
class in the `app/console/commands` directory and register
it inside `commands` object of `.athennarc.json` file.
Don't worry if this directory does not exist in your
application‚Äîit will be created the first time you run the
`make:command` Artisan command:

```shell
./node artisan make:command SendEmails
```

## Commands structure

Athenna commands are represented as classes and always extend 
the `BaseCommand` class. You define the command `signature` and 
`description` as static properties on the class itself:

```typescript
export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'sendEmails'
  }

  public static description(): string {
      return 'The description of sendEmails command'
  }

  public async handle(): Promise<void> {
    //
  }
}
```

- `signature` - The signature is basicaly the command. You will
always use this signature to call your command in terminal. It 
should always be a string.
- `description` - The description is a short description of what
your command does, it will always be displayed in the help output.
- `handle` - The handle method will contain the logic of your 
command, this method will be called when executing your command.

### Booting the app within the command

Artisan commands do not boot your application before running 
the command. If your command relies on the application code, 
you must instruct the command to load the application first 
and then execute the `handle` method:

```json title=".athennarc.json"
{
  "commands": {
    "sendEmails": {
      "path": "#app/console/commands/SendEmails",
      "loadApp": true üëà
    }
  }
}
```

Now we are able to request any dependencies we need using
the `@Inject()` annotation:

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Inject()
  private mailgunService: MailgunService üëà

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

### Constructor injection is not allowed

The application is bootstrapped only after your command is
already registered, meaning that you can't use the
automatic constructor injection with commands to resolve
your dependencies:

#### ‚ùå Does not work

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  public constructor(private mailgunService: MailgunService) { üëà
    super()
  }

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

#### ‚úÖ Works

```typescript
import { Inject } from '@athenna/ioc'
import { BaseCommand } from '@athenna/artisan'
import { MailgunService } from '#app/services/MailgunService'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Inject()
  private mailgunService: MailgunService üëà

  public async handle(): Promise<void> {
    const msg = 'People reading this will have a wonderful day! ü•≥'

    await this.mailgunService.send(msg)
  }
}
```

:::tip

For greater code reuse, it is good practice keeping your
console commands light and let them defer to application
services to accomplish their tasks. In the example above,
note that we inject a service class to do the "heavy
lifting" of sending the e-mails.

:::

## Calling commands in runtime

Sometimes you may wish to call other commands from an
existing Artisan command or from any other part of your
application. You may do so using the `call()` method from
Artisan. This method accepts the command string with its
arguments and options:

```typescript
import { Artisan } from '@athenna/artisan'

await Artisan.call('make:controller TestController')
```

If you want to verify if your command has generated some
output in `stdout` or `stderr` you can use the
`callInChild()` method:

```typescript
const { stdout, stderr } = await Artisan.callInChild('make:controller TestController')

assert.isTrue(stdout.includes('[ MAKING CONTROLLER ]'))
assert.isUndefined(stderr)
```

By default this method will look to the `Path.boostrap('artisan.ts')`
file to execute your command, but you can change the file to be used
setting the path to it as second parameter:

```typescript
const command = 'make:controller TestController'
const artisanPath = Path.pwd(`artisan.${Path.ext()}`)

await Artisan.callInChild(command, artisanPath)
```

## Defining input expectations

When writing console commands, it is common to gather
input from the user through arguments or options. Athenna
makes it very convenient to define the input you expect
from the user using the `@Argument()` and `@Option()`
annotations on your commands. See the example:

```typescript
import { Inject } from '@athenna/ioc'
import { MailgunService } from '#app/services/MailgunService'
import { Option, Argument, BaseCommand } from '@athenna/artisan'

export class SendEmails extends BaseCommand {
  public static signature(): string {
      return 'mail:send'
  }

  public static description(): string {
      return 'Send an email.'
  }

  @Argument()
  private email: string

  @Option({
    signature: '-s, --subject <subject>',
    default: 'Athenna',
    description: 'Set the subject of the email.',
  })
  private subject: string

  @Inject()
  private mailgunService: MailgunService

  public async handle(): Promise<void> {
    const message = 'Hello from Athenna!'

    await this.mailgunService.send(this.email, {
      message,
      subject: this.subject,
    })
  }
}
```

### Arguments

Command arguments are positional, and they are accepted 
in the same order as you define them in your class. 
For example:

```typescript
import { Argument, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Argument()
  public name: string

  @Argument()
  public age: string
}
```

```shell
./node artisan greet <name> <age>
```

#### Spread/Variadic arguments

The `@Argument()` annotation allows you to define a 
catch-all argument. It is like the rest parameters 
in JavaScript and must always be the last argument:

```typescript
import { Argument, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Argument()
  public age: string

  @Argument({ signature: '<names...>' }) üëà
  public names: string[] üëà

  public async handle() {
    console.log(this.age, this.names)
  }
}
```

```shell
./node artisan greet 22 lenon txsoura
```

Will output:

```typescript
22 [ 'lenon', 'txsoura' ]
```

#### Arguments options

The `@Argument()` annotation accept the following options:

- `signature` - The signature of the argument. If not present
the name of the class property will be used.
- `description` - The description of the argument. This will
be displayed in the help output.
- `required` - Set if the argument is required or not. This
could also be done in the `signature` using `<argName>` for 
required and `[argName]` for optional.

### Options

You define the options using the `@Option()` annotation:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Option({ signature: '-n, --name <name>' })
  public name: string

  public async handle() {
    console.log('hey', this.name)
  }
}
```

```shell
./node artisan greet -n lenon
```

Will output:

```typescript
hey lenon
```

#### Negatable boolean options

You can define a boolean option long name with a 
leading `no-` to set the option value to `false` 
when used. Defined alone this also makes the option 
`true` by default.

If you define `--foo` first, adding `--no-foo` does 
not change the default value from what it would otherwise be:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class AthennaPizzeria extends BaseCommand {
  public static signature(): string {
    return 'pizza'
  }

  @Option({ signature: '--no-sauce' })
  public addSauce: boolean

  @Option({ signature: '--cheese <flavour>' })
  public cheeseFlavour: string

  @Option({ signature: '--no-cheese' })
  public addCheese: boolean

  public async handle() {
    const sauceStr = this.addSauce ? 'sauce' : 'no sauce'
    const cheeseStr = (this.addCheese === false) ? 'no cheese' : `${this.chesseFlavour} cheese`;

    console.log(`You ordered a pizza with ${sauceStr} and ${cheeseStr}`);
  }
}
```

```shell
./node artisan pizza
You ordered a pizza with sauce and mozzarella cheese

./node artisan pizza --sauce
error: unknown option '--sauce'

./node artisan pizza --cheese=blue
You ordered a pizza with sauce and blue cheese

./node artisan pizza --no-sauce --no-cheese
You ordered a pizza with no sauce and no cheese
```

#### Spread/Variadic options

The `@Argument()` annotation allows you to define a 
catch-all argument. It is like the rest parameters 
in JavaScript and must always be the last argument:

```typescript
import { Option, BaseCommand } from '@athenna/artisan'

export class Greet extends BaseCommand {
  public static signature(): string {
    return 'greet'
  }

  @Option({ signature: '--names <names...>' }) üëà
  public names: string[] üëà

  public async handle() {
    console.log(this.names)
  }
}
```

```shell
./node artisan greet --names=lenon --names=txsoura
```

Will output:

```typescript
[ 'lenon', 'txsoura' ]
```

#### Option options

The `@Option()` annotation accept the following options:

- `signature` - The signature of the option. If not present
the name of the class property will be used.
- `description` - The description of the option. This will
be displayed in the help output.
- `default` - Set the default value for the option if not 
present.

## Prompts

Coming soon

## Logger and UI

Coming soon

## Generating templates in commands

Coming soon

## Manipulating `.athennarc.json` in commands

Coming soon
