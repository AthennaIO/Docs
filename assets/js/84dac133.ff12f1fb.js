"use strict";(self.webpackChunk_athenna_docs=self.webpackChunk_athenna_docs||[]).push([[805],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>g});var a=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function m(n,e){if(null==n)return{};var t,a,o=function(n,e){if(null==n)return{};var t,a,o={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var s=a.createContext({}),l=function(n){var e=a.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},c=function(n){var e=l(n.components);return a.createElement(s.Provider,{value:e},n.children)},d="mdxType",p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(n,e){var t=n.components,o=n.mdxType,i=n.originalType,s=n.parentName,c=m(n,["components","mdxType","originalType","parentName"]),d=l(t),u=o,g=d["".concat(s,".").concat(u)]||d[u]||p[u]||i;return t?a.createElement(g,r(r({ref:e},c),{},{components:t})):a.createElement(g,r({ref:e},c))}));function g(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var i=t.length,r=new Array(i);r[0]=u;var m={};for(var s in e)hasOwnProperty.call(e,s)&&(m[s]=e[s]);m.originalType=n,m[d]="string"==typeof n?n:o,r[1]=m;for(var l=2;l<i;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9528:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>m,toc:()=>l});var a=t(7462),o=(t(7294),t(3905));const i={title:"Commands",sidebar_position:1,description:"See how to create and configure your CLI commands.",tags:["CLI Application","Commands"]},r="Commands",m={unversionedId:"cli-application/commands",id:"cli-application/commands",title:"Commands",description:"See how to create and configure your CLI commands.",source:"@site/docs/cli-application/commands.mdx",sourceDirName:"cli-application",slug:"/cli-application/commands",permalink:"/docs/cli-application/commands",draft:!1,editUrl:"https://github.com/AthennaIO/Docs/tree/main/docs/cli-application/commands.mdx",tags:[{label:"CLI Application",permalink:"/docs/tags/cli-application"},{label:"Commands",permalink:"/docs/tags/commands"}],version:"current",sidebarPosition:1,frontMatter:{title:"Commands",sidebar_position:1,description:"See how to create and configure your CLI commands.",tags:["CLI Application","Commands"]},sidebar:"tutorialSidebar",previous:{title:"CLI Application",permalink:"/docs/cli-application"},next:{title:"Running",permalink:"/docs/cli-application/running"}},s={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Writing commands",id:"writing-commands",level:2},{value:"Generating commands",id:"generating-commands",level:3},{value:"Commands structure",id:"commands-structure",level:3},{value:"Defining input expectations",id:"defining-input-expectations",level:3},{value:"Registering commands",id:"registering-commands",level:2},{value:"Calling commands in runtime",id:"calling-commands-in-runtime",level:2}],c={toc:l},d="wrapper";function p(n){let{components:e,...t}=n;return(0,o.kt)(d,(0,a.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"commands"},"Commands"),(0,o.kt)("p",null,"See how to create and configure your CLI commands."),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"In Athenna you are able to create your own CLI application\ncreating your own commands by extending the abstract class\n",(0,o.kt)("inlineCode",{parentName:"p"},"Command")," and implement its methods."),(0,o.kt)("h2",{id:"writing-commands"},"Writing commands"),(0,o.kt)("p",null,"In addition to the commands provided with Artisan, you may\nbuild your own custom commands. Commands are typically stored\nin the ",(0,o.kt)("inlineCode",{parentName:"p"},"app/Console/Commands")," directory; however, you are\nfree to choose your own storage location as long as your\ncommands can be imported."),(0,o.kt)("h3",{id:"generating-commands"},"Generating commands"),(0,o.kt)("p",null,"To create a new command, you may use the ",(0,o.kt)("inlineCode",{parentName:"p"},"make:command"),"\nArtisan command. This command will create a new command\nclass in the ",(0,o.kt)("inlineCode",{parentName:"p"},"app/Console/Commands")," directory and register\nit inside ",(0,o.kt)("inlineCode",{parentName:"p"},"commands")," object of ",(0,o.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file.\nDon't worry if this directory does not exist in your\napplication\u2014it will be created the first time you run the\n",(0,o.kt)("inlineCode",{parentName:"p"},"make:command")," Artisan command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan make:command SendEmails\n")),(0,o.kt)("h3",{id:"commands-structure"},"Commands structure"),(0,o.kt)("p",null,"After generating your command, you should define\nappropriate values for the ",(0,o.kt)("inlineCode",{parentName:"p"},"signature")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"description"),"\nstatic properties of the class. These properties will be\nused when displaying your command on the list screen. The\n",(0,o.kt)("inlineCode",{parentName:"p"},"handle")," method will be called when your command is executed.\nYou may place your command logic in this method."),(0,o.kt)("p",null,"Athenna commands do not bootstrap the entire Athenna\napplication, meaning that all your services will not be\nregistered in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/architecture-concepts/service-container"},"service container"),".\nwhen running your commands. To do so, you need to set the\n",(0,o.kt)("inlineCode",{parentName:"p"},'"loadApp": true')," in your command settings inside\n",(0,o.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file. By default, Athenna commands\ngenerated with ",(0,o.kt)("inlineCode",{parentName:"p"},"make:artisan")," command, will\nalready define ",(0,o.kt)("inlineCode",{parentName:"p"},'"loadApp": true')," for you:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "sendEmails": {\n      "path": "#app/Console/Commands/SendEmails",\n      "loadApp": true\n    }\n  }\n}\n')),(0,o.kt)("p",null,"Now we are able to request any dependencies we need using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject()")," annotation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { BaseCommand } from '@athenna/artisan'\nimport { MailgunService } from '#app/Services/MailgunService'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Inject()\n  private mailgunService: MailgunService \ud83d\udc48\n\n  public async handle(): Promise<void> {\n    //\n  }\n}\n")),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"The application is bootstrapped only after your command is\nalready registered, meaning that you can't use the\nautomatic constructor injection with commands to resolve\nyour dependencies.")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},'For greater code reuse, it is good practice keeping your\nconsole commands light and let them defer to application\nservices to accomplish their tasks. In the example above,\nnote that we inject a service class to do the "heavy\nlifting" of sending the e-mails.')),(0,o.kt)("h3",{id:"defining-input-expectations"},"Defining input expectations"),(0,o.kt)("p",null,"When writing console commands, it is common to gather\ninput from the user through arguments or options. Athenna\nmakes it very convenient to define the input you expect\nfrom the user using the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Argument()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@Option()"),"\nannotations on your commands. See the example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { MailgunService } from '#app/Services/MailgunService'\nimport { Option, Argument, BaseCommand } from '@athenna/artisan'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Argument()\n  private email: string\n\n  @Option({\n    signature: '-s, --subject <subject>',\n    default: 'Athenna',\n    description: 'Set the subject of the email.',\n  })\n  private subject: string\n\n  @Inject()\n  private mailgunService: MailgunService\n\n  public async handle(): Promise<void> {\n    const message = 'Hello from Athenna!'\n\n    await this.mailgunService.send(this.email, {\n      message,\n      subject: this.subject,\n    })\n  }\n}\n")),(0,o.kt)("h2",{id:"registering-commands"},"Registering commands"),(0,o.kt)("p",null,"All of your console commands are registered within your\napplication's ",(0,o.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file. If you have created\nyour command using ",(0,o.kt)("inlineCode",{parentName:"p"},"make:command")," your command will already\nbe registered for you in ",(0,o.kt)("inlineCode",{parentName:"p"},"commands")," object, but we still\nrecommend you to do some adjustments before using your\ncommand."),(0,o.kt)("p",null,"In the example above we have changed the signature of\n",(0,o.kt)("inlineCode",{parentName:"p"},"SendEmails")," command to ",(0,o.kt)("inlineCode",{parentName:"p"},"send:email"),", we should always\nuse the command ",(0,o.kt)("inlineCode",{parentName:"p"},"signature")," as key when registering our\ncommands in ",(0,o.kt)("inlineCode",{parentName:"p"},"commands")," object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "send:email": { \ud83d\udc48\n      "path": "#app/Console/Commands/SendEmails",\n      "loadApp": true\n    }\n  }\n}\n')),(0,o.kt)("p",null,"If you do so, Athenna will always import and load only that\nspecific command that you want to execute, meaning that if\nyou execute the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan send:email lenon@athenna.io\n")),(0,o.kt)("p",null,"Athenna will only import and load ",(0,o.kt)("inlineCode",{parentName:"p"},"SendEmails")," class and\nexecute your command. If you change the key name to any\nvalue different from the command ",(0,o.kt)("inlineCode",{parentName:"p"},"signature")," (",(0,o.kt)("inlineCode",{parentName:"p"},"send:email"),")\nAthenna will load all your commands defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"commands"),"\nobject:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "sendEmails": { \ud83d\udc48 // All commands will be loaded\n      "path": "#app/Console/Commands/SendEmails",\n      "loadApp": true\n    }\n  }\n}\n')),(0,o.kt)("p",null,"Loading all commands might be useful sometimes when your\ncommand wants to ",(0,o.kt)("a",{parentName:"p",href:"#calling-commands-in-runtime"},"execute other commands in runtime"),"\ninside your command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { MailgunService } from '#app/Services/MailgunService'\nimport { Option, Artisan, Argument, BaseCommand } from '@athenna/artisan'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Argument()\n  private email: string\n\n  @Option({\n    signature: '-s, --subject <subject>',\n    default: 'Athenna',\n    description: 'Set the subject of the email.',\n  })\n  private subject: string\n\n  @Inject()\n  private mailgunService: MailgunService\n\n  public async handle(): Promise<void> {\n    const message = 'Hello from Athenna!'\n\n    await this.mailgunService.send(this.email, {\n      message,\n      subject: this.subject,\n    })\n\n    await Artisan.call(`save:email ${this.email}`)\n  }\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Even for this purpose, we recommend you to let the key\nof your command the same of your command ",(0,o.kt)("inlineCode",{parentName:"p"},"signature"),".\nTo load all your commands, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"loadAllCommands"),"\nsetting in your command:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "send:email": {\n      "path": "#app/Console/Commands/SendEmails",\n      "loadApp": true,\n      "loadAllCommands": true \ud83d\udc48 // All commands will be loaded\n    }\n  }\n}\n'))),(0,o.kt)("h2",{id:"calling-commands-in-runtime"},"Calling commands in runtime"),(0,o.kt)("p",null,"Sometimes you may wish to call other commands from an\nexisting Artisan command or from any other part of your\napplication. You may do so using the ",(0,o.kt)("inlineCode",{parentName:"p"},"call()")," method from\nArtisan. This method accepts the command string with its\narguments and options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Artisan } from '@athenna/artisan'\n\nawait Artisan.call('make:controller TestController')\n")),(0,o.kt)("p",null,"If you want to verify if your command has generated some\noutput in ",(0,o.kt)("inlineCode",{parentName:"p"},"stdout")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"stderr")," you can use the\n",(0,o.kt)("inlineCode",{parentName:"p"},"callInChild()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const { stdout, stderr } = await Artisan.callInChild('make:controller TestController')\n\nassert.isTrue(stdout.includes('[ MAKING CONTROLLER ]'))\nassert.isUndefined(stderr)\n")))}p.isMDXComponent=!0}}]);