"use strict";(self.webpackChunk_athenna_docs=self.webpackChunk_athenna_docs||[]).push([[5689],{6829:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=o(5893),t=o(1151);const i={title:"Relationships",sidebar_position:3,description:"See how to create relations between models in Athenna Framework."},a="ORM: Relationships",r={id:"orm/relationships",title:"Relationships",description:"See how to create relations between models in Athenna Framework.",source:"@site/docs/orm/relationships.mdx",sourceDirName:"orm",slug:"/orm/relationships",permalink:"/docs/orm/relationships",draft:!1,unlisted:!1,editUrl:"https://github.com/AthennaIO/Docs/tree/main/docs/orm/relationships.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Relationships",sidebar_position:3,description:"See how to create relations between models in Athenna Framework."},sidebar:"tutorialSidebar",previous:{title:"Query Builder",permalink:"/docs/orm/query-builder"},next:{title:"Extending Models",permalink:"/docs/orm/extending-models"}},l={},d=[{value:"Defining relationships",id:"defining-relationships",level:2},{value:"One To One",id:"one-to-one",level:2},{value:"Defining the inverse of the relationship",id:"defining-the-inverse-of-the-relationship",level:3},{value:"One To Many",id:"one-to-many",level:2},{value:"Defining the inverse of the relationship (Many To One)",id:"defining-the-inverse-of-the-relationship-many-to-one",level:3},{value:"Many To Many",id:"many-to-many",level:2},{value:"Table structure",id:"table-structure",level:3},{value:"Model structure",id:"model-structure",level:3},{value:"Defining the inverse of the relationship",id:"defining-the-inverse-of-the-relationship-1",level:3},{value:"Retrieving pivot table data",id:"retrieving-pivot-table-data",level:3},{value:"Eager loading",id:"eager-loading",level:2},{value:"Inserting &amp; updating related models",id:"inserting--updating-related-models",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"orm-relationships",children:"ORM: Relationships"}),"\n",(0,s.jsx)(n.p,{children:"See how to create relations between models in Athenna Framework."}),"\n",(0,s.jsx)(n.h2,{id:"defining-relationships",children:"Defining relationships"}),"\n",(0,s.jsx)(n.p,{children:"Database tables are often related to one another. For example, a\nblog post may have many comments or an order could be related to\nthe user who placed it. Athenna makes managing and working with\nthese relationships easy, and supports a variety of common\nrelationships that are defined as properties on your model classes\nusing annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import {\n  Column,\n  HasOne,\n  HasMany,\n  BaseModel,\n  BelongsTo,\n  BelongsToMany,\n  type Relation,\n} from '@athenna/database'\n\nimport { Course } from '#app/models/Course'\nimport { Profile } from '#app/models/Profile'\nimport { Comment } from '#app/models/Comment'\nimport { Customer } from '#app/models/Customer'\nimport { UsersCourses } from '#app/models/UsersCourses'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number \n\n  @HasOne(() => Profile)\n  public profile: Relation<Profile> \n\n  @HasMany(() => Comment)\n  public comments: Relation<Comment[]> \n\n  @BelongsTo(() => Customer)\n  public customer: Relation<Customer> \n\n  @BelongsToMany(() => Course, () => UsersCourses) \n  public courses: Relation<Course[]> \n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"Check the full documentation of relationships annotations:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/annotations#has-one",children:(0,s.jsx)(n.code,{children:"@HasOne()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/annotations#has-many",children:(0,s.jsx)(n.code,{children:"@HasMany()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/annotations#belongs-to",children:(0,s.jsx)(n.code,{children:"@BelongsTo()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/annotations#belongs-to-many",children:(0,s.jsx)(n.code,{children:"@BelongsToMany()"})})}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"On this documentation you will see how to setup the following\nrelationships using the above annotations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/relationships#one-to-one",children:"One To One"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/relationships#one-to-many",children:"One To Many"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/orm/relationships#many-to-many",children:"Many To Many"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"one-to-one",children:"One To One"}),"\n",(0,s.jsxs)(n.p,{children:["A one-to-one relationship is a very basic type of database relationship.\nFor example, a ",(0,s.jsx)(n.code,{children:"User"})," model might be associated with one ",(0,s.jsx)(n.code,{children:"Phone"})," model.\nTo define this relationship, we will place a ",(0,s.jsx)(n.code,{children:"phone"})," property on the ",(0,s.jsx)(n.code,{children:"User"}),"\nmodel and annotate it with the ",(0,s.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Phone } from '#app/models/Phone'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, HasOne, type Relation } from '@athenna/database'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number\n\n  @HasOne(() => Phone)\n  public phone: Relation<Phone> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first argument passed to the ",(0,s.jsx)(n.code,{children:"@HasOne()"})," annotation is closure\nthat return the related model class. Once the relationship is defined,\nwe may retrieve the related record using the ",(0,s.jsx)(n.code,{children:"with()"})," method of the\nmodel query builder:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { phone } = await User.query()\n  .with('phone')\n  .find()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since all relationships are extending ",(0,s.jsx)(n.code,{children:"BaseModel"}),", you may add further\nconstraints to the relationship query by adding a closure as second argument\nof the ",(0,s.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { phone } = await User.query()\n  .with('phone')\n  .find()\n\n// Or\n\nconst user = await User.find()\n\nawait user.load('phone', query => query.where('ddd', '+55'))\n\nconsole.log(user.phone)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Athenna determines the foreign key of the relationship based on the\nparent model name. In this case, the ",(0,s.jsx)(n.code,{children:"Phone"})," model is automatically\nassumed to have a ",(0,s.jsx)(n.code,{children:"userId"})," foreign key. If you wish to override this\nconvention, you may pass a second argument to the ",(0,s.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@HasOne(() => Phone, { foreignKey: 'foreignKey' })\npublic phone: Relation<Phone> \n"})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, Athenna assumes that the foreign key should have a\nvalue matching the primary key column of the parent. In other words,\nAthenna will look for the value of the user's id column in the ",(0,s.jsx)(n.code,{children:"userId"}),"\ncolumn of the ",(0,s.jsx)(n.code,{children:"Phone"})," record. If you would like the relationship to\nuse a primary key value other than ",(0,s.jsx)(n.code,{children:"id"}),", you may pass a ",(0,s.jsx)(n.code,{children:"primaryKey"}),"\nproperty to the options in the second argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@HasOne(() => Phone, {\n  primaryKey: 'primaryKey',\n  foreignKey: 'foreignKey'\n})\npublic phone: Relation<Phone> \n"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship",children:"Defining the inverse of the relationship"}),"\n",(0,s.jsxs)(n.p,{children:["So, we can access the ",(0,s.jsx)(n.code,{children:"Phone"})," model from our ",(0,s.jsx)(n.code,{children:"User"})," model.\nNext, let's define a relationship on the ",(0,s.jsx)(n.code,{children:"Phone"})," model that\nwill let us access the user that owns the phone. We can define\nthe inverse of a ",(0,s.jsx)(n.code,{children:"@HasOne()"})," relationship using the ",(0,s.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { User } from '#app/models/User'\nimport type { Relation } from '@athenna/database'\nimport { Column, BelongsTo, BaseModel } from '@athenna/database'\n\nexport class Phone extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public userId: number\n\n  @BelongsTo(() => User)\n  public user: Relation<User> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When invoking the ",(0,s.jsx)(n.code,{children:"with('user')"})," method, Athenna will attempt to find\na ",(0,s.jsx)(n.code,{children:"User"})," model that has an id which matches the ",(0,s.jsx)(n.code,{children:"userId"})," column on the\n",(0,s.jsx)(n.code,{children:"Phone"})," model."]}),"\n",(0,s.jsxs)(n.p,{children:["Athenna determines the foreign key name by examining the name of the\nrelationship model and suffixing it with ",(0,s.jsx)(n.code,{children:"Id"}),". So, in this case,\nAthenna assume that the ",(0,s.jsx)(n.code,{children:"Phone"})," model has a ",(0,s.jsx)(n.code,{children:"userId"})," column. However,\nif the foreign key on the ",(0,s.jsx)(n.code,{children:"Phone"})," model is not ",(0,s.jsx)(n.code,{children:"userId"}),", you may pass\na custom key name as the second argument to the ",(0,s.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => User, { foreignKey: 'foreignKey' })\npublic user: Relation<User> \n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the parent model does not use ",(0,s.jsx)(n.code,{children:"id"})," as its primary key, or you wish\nto find the associated model using a different column, you may pass a\nthird argument to the ",(0,s.jsx)(n.code,{children:"@BelongsTo()"})," method specifying the parent\ntable's custom key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => User, { \n  primaryKey: 'primaryKey',\n  foreignKey: 'foreignKey' \n})\npublic user: Relation<User> \n"})}),"\n",(0,s.jsx)(n.h2,{id:"one-to-many",children:"One To Many"}),"\n",(0,s.jsxs)(n.p,{children:["A one-to-many relationship is used to define relationships where a\nsingle model is the parent to one or more child models. For example,\na blog post may have an infinite number of comments. Like all other\nAthenna relationships, one-to-many relationships are defined by\ndefining a ",(0,s.jsx)(n.code,{children:"@HasMany()"})," annotation in your model class property:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Comment } from '#app/models/Comment'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, HasMany } from '@athenna/database'\n\nexport class Post extends BaseModel {\n  @Column()\n  public id: number\n\n  @HasMany(() => Comment)\n  public comments: Relation<Comment[]> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Remember, Athenna will automatically determine the proper foreign\nkey column for the ",(0,s.jsx)(n.code,{children:"Comment"}),' model. By convention, Athenna will take\nthe "camelCase" name of the parent model and suffix it with ',(0,s.jsx)(n.code,{children:"Id"}),". So,\nin this example, Athenna will assume the foreign key column on the\n",(0,s.jsx)(n.code,{children:"Comment"})," model is ",(0,s.jsx)(n.code,{children:"postId"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Once the relationship method has been defined, we can access the\ndata of related ",(0,s.jsx)(n.code,{children:"comments"})," by using the ",(0,s.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { comments } = await Post.query()\n  .with('comments')\n  .find()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since all relationships are extending ",(0,s.jsx)(n.code,{children:"BaseModel"}),", you may add further\nconstraints to the relationship query by adding a closure as second argument\nof the ",(0,s.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { comments } = await Post.query()\n  .with('comments', query => query.where('title', 'foo'))\n  .find()\n\n// Or\n\nconst post = await Post.find()\n\nawait post.load('comments', query => query.where('title', 'foo'))\n\nconsole.log(post.comments)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Like the ",(0,s.jsx)(n.code,{children:"@HasOne()"})," annotation, you may also override the foreign and\nprimary keys by passing the additional options second argument to the\n",(0,s.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@HasMany(() => Comment, { \n  foreignKey: 'foreignKey',\n  primaryKey: 'primaryKey'\n})\npublic comments: Relation<Comment[]>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship-many-to-one",children:"Defining the inverse of the relationship (Many To One)"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we can access all of a post's comments, let's define a\nrelationship to allow a comment to access its parent post. To\ndefine the inverse of a ",(0,s.jsx)(n.code,{children:"@HasMany()"})," relationship, define a\nrelationship property on the child model annotated with the\n",(0,s.jsx)(n.code,{children:"@BelongsTo()"})," annotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Post } from '#app/models/Post'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, BelongsTo } from '@athenna/database'\n\nexport class Comment extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public postId: number\n\n  @BelongsTo(() => Post)\n  public post: Relation<Post> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And just like the other relationships, once we have defined it in\nour class, we can retrieve a comment's parent post by using the\n",(0,s.jsx)(n.code,{children:"with()"})," and ",(0,s.jsx)(n.code,{children:"load()"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const { post } = await Comment.query()\n  .with('post', query => query.where('title', 'foo'))\n  .find()\n\n// Or\n\nconst comment = await Comment.find()\n\nawait comment.load('post', query => query.where('title', 'foo'))\n\nconsole.log(comment.post)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, Athenna will attempt to find a Post model\nthat has an id which matches the ",(0,s.jsx)(n.code,{children:"postId"})," column on the Comment model."]}),"\n",(0,s.jsxs)(n.p,{children:["Athenna determines the foreign key name by examining the name of the\nrelationship model and suffixing it with ",(0,s.jsx)(n.code,{children:"Id"}),". So, in this case,\nAthenna assume that the ",(0,s.jsx)(n.code,{children:"Comment"})," model has a ",(0,s.jsx)(n.code,{children:"postId"})," column. However,\nif the foreign key on the ",(0,s.jsx)(n.code,{children:"Comment"})," model is not ",(0,s.jsx)(n.code,{children:"postId"}),", you may pass\na custom key name as the second argument to the ",(0,s.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => Post, { foreignKey: 'foreignKey' })\npublic post: Relation<Post[]>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If your parent model does not use ",(0,s.jsx)(n.code,{children:"id"})," as its primary key, or you\nwish to find the associated model using a different column, you\nmay pass a ",(0,s.jsx)(n.code,{children:"primaryKey"})," option specifying your parent table's\ncustom key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => Post, {\n  foreignKey: 'foreignKey',\n  primaryKey: 'primaryKey'\n})\npublic post: Relation<Post[]>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"many-to-many",children:"Many To Many"}),"\n",(0,s.jsx)(n.p,{children:'Many-to-many relations are slightly more complicated than one-to-one\nand one-to-many relationships. An example of a many-to-many relationship\nis a user that has many roles and those roles are also shared by other\nusers in the application. For example, a user may be assigned the role\nof "Author" and "Editor"; however, those roles may also be assigned to\nother users as well. So, a user has many roles and a role has many users.'}),"\n",(0,s.jsx)(n.h3,{id:"table-structure",children:"Table structure"}),"\n",(0,s.jsxs)(n.p,{children:["To define this relationship, three database tables are needed: ",(0,s.jsx)(n.code,{children:"users"}),",\n",(0,s.jsx)(n.code,{children:"roles"}),", and ",(0,s.jsx)(n.code,{children:"roles_users"}),". The ",(0,s.jsx)(n.code,{children:"roles_users"})," table is derived from the\nalphabetical order of the related model names and contains ",(0,s.jsx)(n.code,{children:"userId"}),"\nand ",(0,s.jsx)(n.code,{children:"roleId"})," columns. This table is used as an intermediate table\nlinking the users and roles."]}),"\n",(0,s.jsxs)(n.p,{children:["Remember, since a role can belong to many users, we cannot simply\nplace a ",(0,s.jsx)(n.code,{children:"userId"})," column on the ",(0,s.jsx)(n.code,{children:"roles"})," table. This would mean that a\nrole could only belong to a single user. In order to provide support\nfor roles being assigned to multiple users, the ",(0,s.jsx)(n.code,{children:"roles_users"})," table\nis needed. We can summarize the relationship's table structure like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"users\n    id - integer\n    name - string\n \nroles\n    id - integer\n    name - string\n \nroles_users\n    userId - integer\n    roleId - integer\n"})}),"\n",(0,s.jsx)(n.h3,{id:"model-structure",children:"Model structure"}),"\n",(0,s.jsxs)(n.p,{children:["Many-to-many relationships are defined by defining a property annotated\nwith the ",(0,s.jsx)(n.code,{children:"@BelongsToMany()"})," annotation. But before we check how to define\nthis annotation, we need to first create our ",(0,s.jsx)(n.code,{children:"RolesUsers"})," pivot model:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Role } from '#app/models/Role'\nimport { User } from '#app/models/User'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, BelongsTo } from '@athenna/database'\n\nexport class RolesUsers extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public roleId: number\n\n  @Column()\n  public userId: number\n\n  @BelongsTo(() => Role)\n  public role: Relation<Role> \n\n  @BelongsTo(() => User)\n  public user: Relation<User> \n\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And now let's define the roles relation on our ",(0,s.jsx)(n.code,{children:"User"})," model. The first\nargument passed to the annotations is a closure that returns the related\nmodel class and the second argument is a closure that returns the pivot\nmodel:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Role } from '#app/models/Role'\nimport type { Relation } from '@athenna/database'\nimport { RolesUsers } from '#app/models/RolesUsers'\nimport { Column, BaseModel, BelongsToMany } from '@athenna/database'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public name: string\n\n  @BelongsToMany(() => Role, () => RolesUsers)\n  public roles: Relation<Role[]> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once the relationship is defined, you may access the user's roles using\nthe ",(0,s.jsx)(n.code,{children:"with()"})," or ",(0,s.jsx)(n.code,{children:"load()"})," methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const user = await User.query()\n  .with('roles', query => query.select('id'))\n  .find()\n\n// Or\n\nconst user = await User.find()\n\nawait user.load('roles', query => query.select('id'))\n\nconsole.log(user.roles)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To determine the table name of the relationship's pivot table,\nAthenna will call the ",(0,s.jsx)(n.code,{children:"table()"})," method of the pivot model. However, you\nare free to override this convention. You may do so by passing a third\nargument to the ",(0,s.jsx)(n.code,{children:"@BelongsToMany()"})," annotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsToMany(() => Role, () => RolesUsers, {\n  pivotTable: 'roles_users'\n})\npublic roles: Relation<Roles[]>\n"})}),"\n",(0,s.jsx)(n.p,{children:"In addition to customizing the name of the pivot table, you may also\ncustomize the column names of the keys on the table by passing additional\narguments to the options:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@BelongsToMany(() => Role, () => RolesUsers, {\n  pivotTable: 'roles_users',\n  primaryKey: 'id',\n  foreignKey: 'userId',\n  relationPrimaryKey: 'id',\n  relationForeignKey: 'roleId'\n})\npublic roles: Relation<Roles[]>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship-1",children:"Defining the inverse of the relationship"}),"\n",(0,s.jsxs)(n.p,{children:['To define the "inverse" of a many-to-many relationship, is basically\nthe same process of defining on the parent model. To complete our\nuser / role example, let\'s define the ',(0,s.jsx)(n.code,{children:"users"})," property on the ",(0,s.jsx)(n.code,{children:"Role"}),"\nmodel:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { User } from '#app/models/User'\nimport type { Relation } from '@athenna/database'\nimport { RolesUsers } from '#app/models/RolesUsers'\nimport { Column, BaseModel, BelongsToMany } from '@athenna/database'\n\nexport class Role extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public name: string\n\n  @BelongsToMany(() => User, () => RolesUsers)\n  public users: Relation<User[]> \n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, the relationship is defined exactly the same as its ",(0,s.jsx)(n.code,{children:"User"}),"\nmodel counterpart with the exception of referencing the ",(0,s.jsx)(n.code,{children:"User"})," model.\nSince we're reusing the ",(0,s.jsx)(n.code,{children:"@BelongsToMany()"}),' annotation, all of the usual\ntable and key customization options are available when defining the\n"inverse" of many-to-many relationships.']}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-pivot-table-data",children:"Retrieving pivot table data"}),"\n",(0,s.jsx)(n.p,{children:"As you have already learned, working with many-to-many relations requires\nthe presence of a pivot table and it pivot model, meaning that if you need\nto retrieve the data from the pivot table, you can simply use the pivot model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const user = await User.find()\nconst role = await Role.find()\n\nconst rolesUsers = await RolesUsers.query()\n  .where('userId', user.id)\n  .where('roleId', role.id)\n  .findMany()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"eager-loading",children:"Eager loading"}),"\n",(0,s.jsx)(n.p,{children:"Comming soon..."}),"\n",(0,s.jsx)(n.h2,{id:"inserting--updating-related-models",children:"Inserting & updating related models"}),"\n",(0,s.jsx)(n.p,{children:"Comming soon..."})]})}function c(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>r,a:()=>a});var s=o(7294);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);