"use strict";(self.webpackChunk_athenna_docs=self.webpackChunk_athenna_docs||[]).push([[8043],{830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=t(5893),o=t(1151);t(9965);const r={title:"Application Lifecycle",sidebar_position:1,description:"Understand each one of the Athenna applications lifecycles."},a="Application Lifecycle",l={id:"architecture-concepts/application-lifecycle",title:"Application Lifecycle",description:"Understand each one of the Athenna applications lifecycles.",source:"@site/docs/architecture-concepts/application-lifecycle.mdx",sourceDirName:"architecture-concepts",slug:"/architecture-concepts/application-lifecycle",permalink:"/docs/architecture-concepts/application-lifecycle",draft:!1,unlisted:!1,editUrl:"https://github.com/AthennaIO/Docs/tree/main/docs/architecture-concepts/application-lifecycle.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Application Lifecycle",sidebar_position:1,description:"Understand each one of the Athenna applications lifecycles."},sidebar:"tutorialSidebar",previous:{title:"Directory Structure",permalink:"/docs/getting-started/directory-structure"},next:{title:"Service Container",permalink:"/docs/architecture-concepts/service-container"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Athenna foundation lifecycle",id:"athenna-foundation-lifecycle",level:2},{value:"Loading the foundation",id:"loading-the-foundation",level:2},{value:"Rc file",id:"rc-file",level:3},{value:"Other operations",id:"other-operations",level:3},{value:"Firing the foundation",id:"firing-the-foundation",level:3},{value:"Environment variables",id:"environment-variables",level:4},{value:"Configuration files",id:"configuration-files",level:4},{value:"Service providers",id:"service-providers",level:4},{value:"Preloads",id:"preloads",level:4},{value:"REST API lifecycle",id:"rest-api-lifecycle",level:2},{value:"Kernel",id:"kernel",level:3},{value:"Routes",id:"routes",level:3},{value:"Finish up",id:"finish-up",level:3},{value:"Cli and Commands lifecycle",id:"cli-and-commands-lifecycle",level:2},{value:"Kernel",id:"kernel-1",level:3},{value:"Execution",id:"execution",level:3},{value:"Finish up",id:"finish-up-1",level:3},{value:"Focus on service providers",id:"focus-on-service-providers",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"application-lifecycle",children:"Application Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"Understand each one of the Athenna applications lifecycle."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:'When using any tool in the "real world", you feel more confident if\nyou understand how that tool works. Application development is no\ndifferent. When you understand how your development tools function,\nyou feel more comfortable and confident using them.'}),"\n",(0,i.jsx)(n.p,{children:"The goal of this document is to give you a good, high-level overview\nof how the Athenna framework works. By getting to know the overall\nframework better, everything feels less \"magical\" and you will be more\nconfident building your applications. If you don't understand all the\nterms right away, don't lose heart! Just try to get a basic grasp of\nwhat is going on, and your knowledge will grow as you explore other\nsections of the documentation."}),"\n",(0,i.jsx)(n.h2,{id:"athenna-foundation-lifecycle",children:"Athenna foundation lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"The Athenna foundation is everything that is not coupled to the type of\napplication you are using. Meaning that no matter what is the type of\napplication you are using to build your solution, the explanation bellow\nis valid for all of them."}),"\n",(0,i.jsxs)(n.p,{children:["The entry point of an Athenna application is the ",(0,i.jsx)(n.code,{children:"Path.bootstrap('main.ts')"}),".\nThe first action taken by Athenna itself is to create an instance of the\napplication and then boot it."]}),"\n",(0,i.jsx)(n.h2,{id:"loading-the-foundation",children:"Loading the foundation"}),"\n",(0,i.jsx)(n.h3,{id:"rc-file",children:"Rc file"}),"\n",(0,i.jsx)(n.p,{children:"The RC file is the first thing Athenna will do when booting the\napplication. The RC file is responsible to configure your entire\nworkspace and certain runtime settings of your application."}),"\n",(0,i.jsx)(n.h3,{id:"other-operations",children:"Other operations"}),"\n",(0,i.jsx)(n.p,{children:"Some other operation will be done when loading the foundation, such as:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Verify if your ",(0,i.jsxs)(n.a,{href:"https://docs.npmjs.com/cli/v9/configuring-npm/package-json#engines",children:["engines in ",(0,i.jsx)(n.code,{children:"package.json"})]})," is supported."]}),"\n",(0,i.jsx)(n.li,{children:"Register the Athenna logger provider."}),"\n",(0,i.jsx)(n.li,{children:"Register an uncaught exception handler."}),"\n",(0,i.jsx)(n.li,{children:"Define your application root path."}),"\n",(0,i.jsxs)(n.li,{children:["Register ",(0,i.jsx)(n.code,{children:"Ignite"})," class in the service container."]}),"\n",(0,i.jsx)(n.li,{children:"Define application signals for graceful shutdown."}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The process of loading the Athenna foundation is triggered by the\n",(0,i.jsx)(n.code,{children:"Ignite.load()"})," method."]})}),"\n",(0,i.jsx)(n.h3,{id:"firing-the-foundation",children:"Firing the foundation"}),"\n",(0,i.jsx)(n.p,{children:"The Athenna foundation will automatically be fired internally depending\non the type of application you are using, let's see all the operations\nexecuted in order to get Athenna foundation done:"}),"\n",(0,i.jsx)(n.h4,{id:"environment-variables",children:"Environment variables"}),"\n",(0,i.jsxs)(n.p,{children:["The first thing Athenna will do when firing the foundation is to load\nyour environment variables files. You can learn more about what is and\nhow to configure your environment variables in ",(0,i.jsx)(n.a,{href:"/docs/getting-started/configuration#environment-configuration",children:"the environment\nconfiguration documentation section"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"configuration-files",children:"Configuration files"}),"\n",(0,i.jsxs)(n.p,{children:["Afterwards Athenna will load all the configuration files found inside\nthe path returned by the ",(0,i.jsx)(n.code,{children:"Path.config"})," method. You can learn more about\nwhat is and how to configure your configuration files in\n",(0,i.jsx)(n.a,{href:"/docs/getting-started/configuration#configuration-files",children:"the configuration files documentation section"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"service-providers",children:"Service providers"}),"\n",(0,i.jsxs)(n.p,{children:["One of the most important kernel bootstrapping actions is loading the\nservice providers for your application. All the service providers for\nthe application are configured in the ",(0,i.jsx)(n.code,{children:".athennarc.json"})," in the\n",(0,i.jsx)(n.code,{children:"providers"})," array."]}),"\n",(0,i.jsxs)(n.p,{children:["Athenna will iterate through this list of providers and instantiate each\nof them. After instantiating the providers, the ",(0,i.jsx)(n.code,{children:"register"})," method will\nbe called on all the providers. Then, once all the providers have been\nregistered, the ",(0,i.jsx)(n.code,{children:"boot"})," method will be called on each provider. This is\nso service providers may depend on every container binding being\nregistered and available by the time their boot method is executed."]}),"\n",(0,i.jsx)(n.p,{children:"Service providers are responsible for bootstrapping all the frameworks\nvarious components, such as the database, http server, validation,\nservices and routing components. Essentially, every major feature\noffered by Athenna is bootstrapped and configured by a service\nprovider. Since they bootstrap and configure so many features offered\nby the framework, service providers are the most important aspect of\nthe entire Athenna bootstrap process."}),"\n",(0,i.jsx)(n.h4,{id:"preloads",children:"Preloads"}),"\n",(0,i.jsxs)(n.p,{children:["Preload files are loaded at the time of booting the application. The\nfiles are loaded right after booting the service providers. A preload\nfile could be useful to execute some operation before bootstrapping\nthe application. All the preloads for the application are configured\nin the ",(0,i.jsx)(n.code,{children:".athennarc.json"})," in the ",(0,i.jsx)(n.code,{children:"preloads"})," array."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The process of firing the Athenna foundation is triggered by the\n",(0,i.jsx)(n.code,{children:"Ignite::fire()"})," static method. But if you check your ",(0,i.jsx)(n.code,{children:"Path.bootstrap('main.ts')"}),"\nentrypoint file, you will see that this method is not called directly.\nThe reason for this is that this method is called internally depending\non the type of application you are using. Let's cover some examples\nbellow:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"REST API"})," application needs to fire the foundation first because\nit depends on service providers to register your controllers, services,\nmiddlewares, routes, etc."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"CLI"})," application and Artisan commands does not fire the foundation\nbecause commands do not depend on registering providers, loading\nenvironment variables and configuration files, for example. But, if your\ncommand got the ",(0,i.jsx)(n.code,{children:"loadApp"})," setting equals to ",(0,i.jsx)(n.code,{children:"true"})," in ",(0,i.jsx)(n.code,{children:".athennarc.json"}),",\nthe foundation will be fired before executing your command."]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"rest-api-lifecycle",children:"REST API lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"kernel",children:"Kernel"}),"\n",(0,i.jsxs)(n.p,{children:["The Kernel class is responsible by defining some bootstraps that will\nbe run before reading your ",(0,i.jsx)(n.code,{children:"Path.routes('http.ts')"})," file. These bootstraps\nconfigure error handling for requests, tracing and logging, detect the\napplication environment, and perform other tasks that need to be done\nbefore the request is actually handled. Typically, these classes handle\ninternal Athenna configuration that you do not need to worry about."]}),"\n",(0,i.jsxs)(n.p,{children:["The Kernel is also responsible by registering your middlewares and\ncontrollers defined in your ",(0,i.jsx)(n.code,{children:".athennarc.json"})," file. By default, Athenna\nwill always use the default implementation ",(0,i.jsx)(n.code,{children:"HttpKernel"})," class imported\nfrom ",(0,i.jsx)(n.code,{children:"@athenna/http"})," package. If you prefer, you can create your custom\nKernel implementation, extending the default ",(0,i.jsx)(n.code,{children:"HttpKernel"})," class and\nregistering it in your ",(0,i.jsx)(n.code,{children:"Ignite.httpServer"})," method call:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { HttpKernel } from '@athenna/http'\n\nexport class CustomKernel extends HttpKernel {\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["You can check all the methods available for you to override in your\ncustom kernel implementation taking a look at ",(0,i.jsx)(n.a,{href:"https://github.com/AthennaIO/Http/blob/develop/src/kernels/HttpKernel.ts",children:"HttpKernel"}),"\nimplementation code."]})}),"\n",(0,i.jsxs)(n.p,{children:["Then, you can register your ",(0,i.jsx)(n.code,{children:"CustomKernel"})," in your ",(0,i.jsx)(n.code,{children:"Path.bootstrap('main.ts')"}),"\nfile:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Ignite } from '@athenna/core'\n\nconst ignite = await new Ignite().load(import.meta.url)\n\nawait ignite.httpServer({ kernelPath: '#app/http/CustomKernel' })\n"})}),"\n",(0,i.jsx)(n.h3,{id:"routes",children:"Routes"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Path.routes('http.ts')"})," file is the entrypoint for all your http requests.\nThis file is responsible to create a contract between your client and\nyour application. It Is in here that we define all our routes and the\nhandlers/controllers who will handle the client request."]}),"\n",(0,i.jsxs)(n.p,{children:["One of the most important service providers in your application is the\n",(0,i.jsx)(n.code,{children:"HttpRouteProvider"}),". This service provider adds in the container the\n",(0,i.jsx)(n.code,{children:"Route"})," class instance used inside ",(0,i.jsx)(n.code,{children:"Path.routes('http.ts')"})," file."]}),"\n",(0,i.jsx)(n.p,{children:"When the client request arrives, the server first executes all your\nglobal middlewares, then it will execute all your route middlewares.\nOnce it finishes, it goes for your handler/controller. See the example:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    clientRequest(("Client Request"))\n    globalMiddlewares{"Global Middlewares"}\n    routeMiddlewares{"Route Middlewares"}\n    controller("Controller")\n\n    clientRequest --\x3e globalMiddlewares\n    globalMiddlewares --\x3e routeMiddlewares\n    routeMiddlewares --\x3e controller'}),"\n",(0,i.jsx)(n.h3,{id:"finish-up",children:"Finish up"}),"\n",(0,i.jsx)(n.p,{children:"Once the controller/handler function returns a response, the response will\ntravel back outward through each global interceptor, and then route's\ninterceptor, giving the application a chance to modify or examine the\noutgoing response. See the example:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    clientRequest(("Client Request"))\n    globalInterceptors{"Global Interceptors"}\n    routeInterceptors{"Route Interceptors"}\n    controller("Controller")\n\n    controller --\x3e globalInterceptors\n    globalInterceptors --\x3e routeInterceptors\n    routeInterceptors --\x3e clientRequest'}),"\n",(0,i.jsx)(n.p,{children:"As you can see in the example, the response content is sent to the client. The\nrequest finishes for the client but not for the server. Now it's time to\nexecute the global and route terminators. The terminators are executed when a\nresponse has been sent, so you will not be able to send more data to the\nclient. It can, however, be useful for sending data to external services, for\nexample, create metrics of the entire request. See the example:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    globalTerminators{"Global Terminators"}\n    routeTerminators{"Route Terminators"}\n\n    globalTerminators --\x3e routeTerminators'}),"\n",(0,i.jsx)(n.p,{children:"Finally, once all terminators are executed, the request finishes in the\nserver. We've finished our journey through the entire REST API lifecycle \ud83e\udd73."}),"\n",(0,i.jsx)(n.h2,{id:"cli-and-commands-lifecycle",children:"Cli and Commands lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"kernel-1",children:"Kernel"}),"\n",(0,i.jsx)(n.p,{children:"The Kernel class is responsible for defining some bootstraps that will be run\nbefore registering your commands. These bootstraps configure error handling\nfor commands, detect the application environment, and perform other tasks that\nneed to be done before the command is actually handled. Typically, these\nclasses handle internal Athenna configuration that you do not need to worry\nabout."}),"\n",(0,i.jsxs)(n.p,{children:["The Kernel is also responsible for registering your commands defined in your\n",(0,i.jsx)(n.code,{children:".athennarc.json"})," file. By default, Athenna will always use the default\nimplementation ",(0,i.jsx)(n.code,{children:"ConsoleKernel"})," class imported from ",(0,i.jsx)(n.code,{children:"@athenna/http"})," package. If\nyou prefer, you can create your custom Kernel implementation, extending the\ndefault ConsoleKernel class and registering it in your ",(0,i.jsx)(n.code,{children:"Ignite.console()"})," method\ncall:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { ConsoleKernel } from '@athenna/http'\n\nexport class CustomKernel extends ConsoleKernel {\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["You can check all the methods available for you to override in your custom\nkernel implementation taking a look at ",(0,i.jsx)(n.a,{href:"https://github.com/AthennaIO/Artisan/blob/develop/src/kernels/ConsoleKernel.ts",children:"ConsoleKernel"})," implementation code."]})}),"\n",(0,i.jsxs)(n.p,{children:["Then, you can register your ",(0,i.jsx)(n.code,{children:"CustomKernel"})," in your\n",(0,i.jsx)(n.code,{children:"Path.bootstrap('main.ts')"})," or ",(0,i.jsx)(n.code,{children:"Path.bootstrap('artisan.ts')"})," file:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Ignite } from '@athenna/core'\n\nconst ignite = await new Ignite().load(import.meta.url, {\n  bootLogs: false\n})\n\nawait ignite.console(process.argv, { \n  kernelPath: '#app/http/CustomKernel' \n})\n"})}),"\n",(0,i.jsx)(n.h3,{id:"execution",children:"Execution"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Path.routes('console.ts')"})," and the ",(0,i.jsx)(n.code,{children:"commands"})," property of\n",(0,i.jsx)(n.code,{children:".athennarc.json"})," file is where that we define all ours commands\nand the handlers who will handle the terminal arguments."]}),"\n",(0,i.jsxs)(n.p,{children:["When the terminal arguments arrive, the application will be bootstrapped\nbased on the command that you are asking to execute. Let's suppose we have\nexecuted the ",(0,i.jsx)(n.code,{children:"hello"})," command defined in our ",(0,i.jsx)(n.code,{children:".athennarc.json"})," file:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "commands": {\n    "hello": {\n      "path": "#app/console/commands/HelloCommand",\n      "loadApp": false,\n      "stayAlive": false,\n      "loadAllCommands": false,\n      "environments": ["console"]\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Since ",(0,i.jsx)(n.code,{children:"loadAllCommands"})," is set to false, the Kernel will load only the ",(0,i.jsx)(n.code,{children:"hello"}),"\ncommand and execute it:"]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    terminalCommand(("Terminal Command"))\n    igniteLoad{"Ignite::load()"}\n    consoleKernel{"ConsoleKernel"}\n    loadAppEqualsTrue{"loadApp === true"}\n    igniteFire{"Ignite::fire()"}\n    defineArgsAndFlags{"Define arguments and flags"}\n    commandHandler("Command Handler")\n\n    terminalCommand --\x3e igniteLoad\n    igniteLoad --\x3e consoleKernel\n    consoleKernel --\x3e loadAppEqualsTrue\n    loadAppEqualsTrue -- true --\x3e igniteFire\n    loadAppEqualsTrue --\x3e defineArgsAndFlags\n    defineArgsAndFlags --\x3e commandHandler'}),"\n",(0,i.jsx)(n.h3,{id:"finish-up-1",children:"Finish up"}),"\n",(0,i.jsxs)(n.p,{children:["Once the command handler function finish, Athenna will verify if the ",(0,i.jsx)(n.code,{children:"stayAlive"}),"\nsetting is set to true, if so, the application will not be terminated, very\nuseful when running command like ",(0,i.jsx)(n.code,{children:"repl"})," and ",(0,i.jsx)(n.code,{children:"serve"}),"."]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    commandHandler("Command Handler")\n    stayAliveEqualsTrue{"stayAlive === true"}\n    leaveAppRunning("Leave application running")\n    processExit("process.exit()")\n\n    commandHandler --\x3e stayAliveEqualsTrue\n    stayAliveEqualsTrue -- true --\x3e leaveAppRunning\n    stayAliveEqualsTrue -- false --\x3e processExit'}),"\n",(0,i.jsx)(n.p,{children:"We've finished our journey through the entire command lifecycle \ud83e\udd73."}),"\n",(0,i.jsx)(n.h2,{id:"focus-on-service-providers",children:"Focus on service providers"}),"\n",(0,i.jsx)(n.p,{children:"Service providers are truly the key to bootstrapping an Athenna application.\nThe application instance is created, the service providers are registered, and\nthe request is handed to the bootstrapped application. It's really that simple!"}),"\n",(0,i.jsxs)(n.p,{children:["Having a firm grasp of how an Athenna application is built and bootstrapped via\nservice providers is very valuable. Your application's default service providers\nare stored in the ",(0,i.jsx)(n.code,{children:"providers"})," directory, and you can create your own provider\nwith the following command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"node artisan make:provider AppProvider\n"})}),"\n",(0,i.jsx)(n.p,{children:"With this new provider you can add your application's own bootstrapping and\nservice container bindings. For large applications, you may wish to create\nseveral service providers, each with more granular bootstrapping for specific\nservices used by your application."})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>a});var i=t(7294);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);