"use strict";(self.webpackChunk_athenna_docs=self.webpackChunk_athenna_docs||[]).push([[805],{9528:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var a=t(7462),i=(t(7294),t(3905)),o=t(2004);const r={title:"Commands",sidebar_position:1,description:"See how to create and configure your CLI commands."},s="Commands",l={unversionedId:"cli-application/commands",id:"cli-application/commands",title:"Commands",description:"See how to create and configure your CLI commands.",source:"@site/docs/cli-application/commands.mdx",sourceDirName:"cli-application",slug:"/cli-application/commands",permalink:"/docs/cli-application/commands",draft:!1,editUrl:"https://github.com/AthennaIO/Docs/tree/main/docs/cli-application/commands.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Commands",sidebar_position:1,description:"See how to create and configure your CLI commands."},sidebar:"tutorialSidebar",previous:{title:"CLI Application",permalink:"/docs/cli-application"},next:{title:"Running",permalink:"/docs/cli-application/running"}},p={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Writing commands",id:"writing-commands",level:2},{value:"Registering commands",id:"registering-commands",level:2},{value:"Commands structure",id:"commands-structure",level:2},{value:"Booting the app within the command",id:"booting-the-app-within-the-command",level:3},{value:"Constructor injection is not allowed",id:"constructor-injection-is-not-allowed",level:3},{value:"\u274c Does not work",id:"-does-not-work",level:4},{value:"\u2705 Works",id:"-works",level:4},{value:"Defining input expectations",id:"defining-input-expectations",level:2},{value:"Arguments",id:"arguments",level:3},{value:"Spread/Variadic arguments",id:"spreadvariadic-arguments",level:4},{value:"Arguments options",id:"arguments-options",level:4},{value:"Options",id:"options",level:3},{value:"Negatable boolean options",id:"negatable-boolean-options",level:4},{value:"Spread/Variadic options",id:"spreadvariadic-options",level:4},{value:"Option options",id:"option-options",level:4},{value:"Prompts",id:"prompts",level:2},{value:"<code>this.prompt.input()</code>",id:"thispromptinput",level:5},{value:"<code>this.prompt.secret()</code>",id:"thispromptsecret",level:4},{value:"<code>this.prompt.confirm()</code>",id:"thispromptconfirm",level:4},{value:"<code>this.prompt.editor()</code>",id:"thisprompteditor",level:4},{value:"<code>this.prompt.list()</code>",id:"thispromptlist",level:4},{value:"<code>this.prompt.checkbox()</code>",id:"thispromptcheckbox",level:4},{value:"Logger and UI",id:"logger-and-ui",level:2},{value:"<code>this.logger.simple()</code>",id:"thisloggersimple",level:4},{value:"<code>this.logger.update()</code>",id:"thisloggerupdate",level:4},{value:"<code>this.logger.rainbow()</code>",id:"thisloggerrainbow",level:4},{value:"<code>this.logger.spinner()</code>",id:"thisloggerspinner",level:4},{value:"<code>this.logger.promiseSpinner()</code>",id:"thisloggerpromisespinner",level:4},{value:"<code>this.logger.table()</code>",id:"thisloggertable",level:4},{value:"<code>this.logger.column()</code>",id:"thisloggercolumn",level:4},{value:"<code>this.logger.action()</code>",id:"thisloggeraction",level:4},{value:"<code>this.logger.instruction()</code>",id:"thisloggerinstruction",level:4},{value:"<code>this.logger.sticker()</code>",id:"thisloggersticker",level:4},{value:"<code>this.logger.task()</code>",id:"thisloggertask",level:4},{value:"Generating templates in commands",id:"generating-templates-in-commands",level:2},{value:"<code>this.generator.path()</code>",id:"thisgeneratorpath",level:4},{value:"<code>this.generator.template()</code>",id:"thisgeneratortemplate",level:4},{value:"<code>this.generator.properties()</code>",id:"thisgeneratorproperties",level:4},{value:"<code>this.generator.setNameProperties()</code>",id:"thisgeneratorsetnameproperties",level:4},{value:"<code>this.generator.make()</code>",id:"thisgeneratormake",level:4},{value:"Manipulating <code>.athennarc.json</code> in commands",id:"manipulating-athennarcjson-in-commands",level:2},{value:"<code>this.rc.file</code>",id:"thisrcfile",level:4},{value:"<code>this.rc.content</code>",id:"thisrccontent",level:4},{value:"<code>this.rc.setFile()</code>",id:"thisrcsetfile",level:4},{value:"<code>this.rc.setTo()</code>",id:"thisrcsetto",level:4},{value:"<code>this.rc.pushTo()</code>",id:"thisrcpushto",level:4},{value:"<code>this.rc.save()</code>",id:"thisrcsave",level:4},{value:"Executing commands programmatically",id:"executing-commands-programmatically",level:2}],c={toc:m},d="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"commands"},"Commands"),(0,i.kt)("p",null,"See how to create and configure your CLI commands."),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In Athenna you are able to create your own CLI application\ncreating your own commands by extending the abstract class\n",(0,i.kt)("inlineCode",{parentName:"p"},"Command")," and implement its methods."),(0,i.kt)("h2",{id:"writing-commands"},"Writing commands"),(0,i.kt)("p",null,"In addition to the commands provided with Artisan, you may\nbuild your own custom commands. Commands are typically stored\nin the ",(0,i.kt)("inlineCode",{parentName:"p"},"app/console/commands")," directory; however, you are\nfree to choose your own storage location as long as your\ncommands can be imported and registered."),(0,i.kt)("p",null,"To create a new command, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"make:command"),"\nArtisan command. This command will create a new command\nclass in the ",(0,i.kt)("inlineCode",{parentName:"p"},"app/console/commands")," directory and register\nit inside ",(0,i.kt)("inlineCode",{parentName:"p"},"commands")," object of ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file.\nDon't worry if this directory does not exist in your\napplication\u2014it will be created the first time you run the\n",(0,i.kt)("inlineCode",{parentName:"p"},"make:command")," Artisan command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan make:command SendEmails\n")),(0,i.kt)("h2",{id:"registering-commands"},"Registering commands"),(0,i.kt)("p",null,"All of your console commands are registered within your\napplication's ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file. If you have created\nyour command using ",(0,i.kt)("inlineCode",{parentName:"p"},"make:command")," your command will already\nbe registered for you in ",(0,i.kt)("inlineCode",{parentName:"p"},"commands")," object, but we still\nrecommend you to do some adjustments before using your\ncommand."),(0,i.kt)("p",null,"In the example above we have changed the signature of\n",(0,i.kt)("inlineCode",{parentName:"p"},"SendEmails")," command to ",(0,i.kt)("inlineCode",{parentName:"p"},"send:email"),", we should always\nuse the command ",(0,i.kt)("inlineCode",{parentName:"p"},"signature")," as key when registering our\ncommands in ",(0,i.kt)("inlineCode",{parentName:"p"},"commands")," object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "send:email": { \ud83d\udc48\n      "path": "#app/console/commands/SendEmails",\n      "loadApp": true\n    }\n  }\n}\n')),(0,i.kt)("p",null,"If you do so, Athenna will always import and load only that\nspecific command that you want to execute, meaning that if\nyou execute the following command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan send:email lenon@athenna.io\n")),(0,i.kt)("p",null,"Athenna will only import and load ",(0,i.kt)("inlineCode",{parentName:"p"},"SendEmails")," class and\nexecute your command. If you change the key name to any\nvalue different from the command ",(0,i.kt)("inlineCode",{parentName:"p"},"signature")," (",(0,i.kt)("inlineCode",{parentName:"p"},"send:email"),")\nAthenna will load all your commands defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"commands"),"\nobject:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "sendEmails": { \ud83d\udc48 // All commands will be loaded\n      "path": "#app/console/commands/SendEmails",\n      "loadApp": true\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Loading all commands might be useful sometimes when your\ncommand wants to ",(0,i.kt)("a",{parentName:"p",href:"#calling-commands-in-runtime"},"execute other commands in runtime"),"\ninside your command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { MailgunService } from '#app/services/MailgunService'\nimport { Option, Artisan, Argument, BaseCommand } from '@athenna/artisan'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Argument()\n  private email: string\n\n  @Option({\n    signature: '-s, --subject <subject>',\n    default: 'Athenna',\n    description: 'Set the subject of the email.',\n  })\n  private subject: string\n\n  @Inject()\n  private mailgunService: MailgunService\n\n  public async handle(): Promise<void> {\n    const message = 'Hello from Athenna!'\n\n    await this.mailgunService.send(this.email, {\n      message,\n      subject: this.subject,\n    })\n\n    await Artisan.call(`save:email ${this.email}`)\n  }\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Even for this purpose, we recommend you to let the key\nof your command the same of your command ",(0,i.kt)("inlineCode",{parentName:"p"},"signature"),".\nTo load all your commands, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"loadAllCommands"),"\nsetting in your command:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "commands": {\n    "send:email": {\n      "path": "#app/console/commands/SendEmails",\n      "loadApp": true,\n      "loadAllCommands": true \ud83d\udc48 // All commands will be loaded\n    }\n  }\n}\n'))),(0,i.kt)("h2",{id:"commands-structure"},"Commands structure"),(0,i.kt)("p",null,"Athenna commands are represented as classes and always extend\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseCommand")," class. You define the command ",(0,i.kt)("inlineCode",{parentName:"p"},"signature"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"description")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"commander")," as static properties on the class itself:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { BaseCommand, type Commander } from '@athenna/artisan'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'sendEmails'\n  }\n\n  public static description(): string {\n      return 'The description of sendEmails command'\n  }\n\n  public static commander(commander: Commander): Commander {\n    return commander\n  }\n\n  public async handle(): Promise<void> {\n    //\n  }\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," - The signature is basicaly the command. You will\nalways use this signature to call your command in terminal. It\nshould always be a string."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description")," - The description is a short description of what\nyour command does, it will always be displayed in the help output."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"commander")," - The commander method should be used when you want\nto set customized options for ",(0,i.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/commander"},"commander"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"handle")," - The handle method will contain the logic of your\ncommand, this method will be called when executing your command.")),(0,i.kt)("h3",{id:"booting-the-app-within-the-command"},"Booting the app within the command"),(0,i.kt)("p",null,"Artisan commands do not boot your application before running\nthe command. If your command relies on the application code,\nyou must instruct the command to load the application first\nand then execute the ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title=".athennarc.json"',title:'".athennarc.json"'},'{\n  "commands": {\n    "sendEmails": {\n      "path": "#app/console/commands/SendEmails",\n      "loadApp": true \ud83d\udc48\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Now we are able to request any dependencies we need using\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject()")," annotation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { BaseCommand } from '@athenna/artisan'\nimport { MailgunService } from '#app/services/MailgunService'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Inject()\n  private mailgunService: MailgunService \ud83d\udc48\n\n  public async handle(): Promise<void> {\n    const msg = 'People reading this will have a wonderful day! \ud83e\udd73'\n\n    await this.mailgunService.send(msg)\n  }\n}\n")),(0,i.kt)("h3",{id:"constructor-injection-is-not-allowed"},"Constructor injection is not allowed"),(0,i.kt)("p",null,"The application is bootstrapped only after your command is\nalready registered, meaning that you can't use the\nautomatic constructor injection with commands to resolve\nyour dependencies:"),(0,i.kt)("h4",{id:"-does-not-work"},"\u274c Does not work"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { BaseCommand } from '@athenna/artisan'\nimport { MailgunService } from '#app/services/MailgunService'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  public constructor(private mailgunService: MailgunService) { \ud83d\udc48\n    super()\n  }\n\n  public async handle(): Promise<void> {\n    const msg = 'People reading this will have a wonderful day! \ud83e\udd73'\n\n    await this.mailgunService.send(msg)\n  }\n}\n")),(0,i.kt)("h4",{id:"-works"},"\u2705 Works"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { BaseCommand } from '@athenna/artisan'\nimport type { MailgunService } from '#app/services/MailgunService'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  public async handle(): Promise<void> {\n    const mailgunService = ioc.safeUse<MailgunService>('App/Services/MailgunService')\n\n    const msg = 'People reading this will have a wonderful day! \ud83e\udd73'\n\n    await mailgunService.send(msg)\n  }\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'For greater code reuse, it is good practice keeping your\nconsole commands light and let them defer to application\nservices to accomplish their tasks. In the example above,\nnote that we inject a service class to do the "heavy\nlifting" of sending the e-mails.')),(0,i.kt)("h2",{id:"defining-input-expectations"},"Defining input expectations"),(0,i.kt)("p",null,"When writing console commands, it is common to gather\ninput from the user through arguments or options. Athenna\nmakes it very convenient to define the input you expect\nfrom the user using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Argument()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@Option()"),"\nannotations on your commands. See the example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Inject } from '@athenna/ioc'\nimport { MailgunService } from '#app/services/MailgunService'\nimport { Option, Argument, BaseCommand } from '@athenna/artisan'\n\nexport class SendEmails extends BaseCommand {\n  public static signature(): string {\n      return 'mail:send'\n  }\n\n  public static description(): string {\n      return 'Send an email.'\n  }\n\n  @Argument()\n  private email: string\n\n  @Option({\n    signature: '-s, --subject <subject>',\n    default: 'Athenna',\n    description: 'Set the subject of the email.',\n  })\n  private subject: string\n\n  @Inject()\n  private mailgunService: MailgunService\n\n  public async handle(): Promise<void> {\n    const message = 'Hello from Athenna!'\n\n    await this.mailgunService.send(this.email, {\n      message,\n      subject: this.subject,\n    })\n  }\n}\n")),(0,i.kt)("h3",{id:"arguments"},"Arguments"),(0,i.kt)("p",null,"Command arguments are positional, and they are accepted\nin the same order as you define them in your class.\nFor example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Argument, BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  @Argument()\n  public name: string\n\n  @Argument()\n  public age: string\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan greet <name> <age>\n")),(0,i.kt)("h4",{id:"spreadvariadic-arguments"},"Spread/Variadic arguments"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Argument()")," annotation allows you to define a\ncatch-all argument. It is like the rest parameters\nin JavaScript and must always be the last argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Argument, BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  @Argument()\n  public age: string\n\n  @Argument({ signature: '<names...>' }) \ud83d\udc48\n  public names: string[] \ud83d\udc48\n\n  public async handle() {\n    console.log(this.age, this.names)\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan greet 22 lenon txsoura\n")),(0,i.kt)("p",null,"Will output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"22 [ 'lenon', 'txsoura' ]\n")),(0,i.kt)("h4",{id:"arguments-options"},"Arguments options"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Argument()")," annotation accept the following options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," - The signature of the argument. If not present\nthe name of the class property will be used."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description")," - The description of the argument. This will\nbe displayed in the help output."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"required")," - Set if the argument is required or not. This\ncould also be done in the ",(0,i.kt)("inlineCode",{parentName:"li"},"signature")," using ",(0,i.kt)("inlineCode",{parentName:"li"},"<argName>")," for\nrequired and ",(0,i.kt)("inlineCode",{parentName:"li"},"[argName]")," for optional.")),(0,i.kt)("h3",{id:"options"},"Options"),(0,i.kt)("p",null,"You define the options using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Option()")," annotation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Option, BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  @Option({ signature: '-n, --name <name>' })\n  public name: string\n\n  public async handle() {\n    console.log('hey', this.name)\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan greet -n lenon\n")),(0,i.kt)("p",null,"Will output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"hey lenon\n")),(0,i.kt)("h4",{id:"negatable-boolean-options"},"Negatable boolean options"),(0,i.kt)("p",null,"You can define a boolean option long name with a\nleading ",(0,i.kt)("inlineCode",{parentName:"p"},"no-")," to set the option value to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"\nwhen used. Defined alone this also makes the option\n",(0,i.kt)("inlineCode",{parentName:"p"},"true")," by default."),(0,i.kt)("p",null,"If you define ",(0,i.kt)("inlineCode",{parentName:"p"},"--foo")," first, adding ",(0,i.kt)("inlineCode",{parentName:"p"},"--no-foo")," does\nnot change the default value from what it would otherwise be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Option, BaseCommand } from '@athenna/artisan'\n\nexport class AthennaPizzeria extends BaseCommand {\n  public static signature(): string {\n    return 'pizza'\n  }\n\n  @Option({ signature: '--no-sauce' })\n  public addSauce: boolean\n\n  @Option({ signature: '--cheese <flavour>' })\n  public cheeseFlavour: string\n\n  @Option({ signature: '--no-cheese' })\n  public addCheese: boolean\n\n  public async handle() {\n    const sauceStr = this.addSauce ? 'sauce' : 'no sauce'\n    const cheeseStr = (this.addCheese === false) ? 'no cheese' : `${this.chesseFlavour} cheese`;\n\n    console.log(`You ordered a pizza with ${sauceStr} and ${cheeseStr}`);\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan pizza\nYou ordered a pizza with sauce and mozzarella cheese\n\n./node artisan pizza --sauce\nerror: unknown option '--sauce'\n\n./node artisan pizza --cheese=blue\nYou ordered a pizza with sauce and blue cheese\n\n./node artisan pizza --no-sauce --no-cheese\nYou ordered a pizza with no sauce and no cheese\n")),(0,i.kt)("h4",{id:"spreadvariadic-options"},"Spread/Variadic options"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Argument()")," annotation allows you to define a\ncatch-all argument. It is like the rest parameters\nin JavaScript and must always be the last argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Option, BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  @Option({ signature: '--names <names...>' }) \ud83d\udc48\n  public names: string[] \ud83d\udc48\n\n  public async handle() {\n    console.log(this.names)\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"./node artisan greet --names=lenon --names=txsoura\n")),(0,i.kt)("p",null,"Will output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"[ 'lenon', 'txsoura' ]\n")),(0,i.kt)("h4",{id:"option-options"},"Option options"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Option()")," annotation accept the following options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signature")," - The signature of the option. If not present\nthe name of the class property will be used."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description")," - The description of the option. This will\nbe displayed in the help output."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default")," - Set the default value for the option if not\npresent.")),(0,i.kt)("h2",{id:"prompts"},"Prompts"),(0,i.kt)("p",null,"Artisan has support for creating interactive\nprompts on the terminal thanks to\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer"},"inquirer"),".\nYou can access the prompts\nmodule using the ",(0,i.kt)("inlineCode",{parentName:"p"},"this.prompt")," property."),(0,i.kt)("p",null,"In the example below, we are using multiple prompts\ntogether:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  public async handle() {\n    const name = await this.prompt.input('What is your name?')\n    const password = await this.prompt.secret('What is your password?')\n    const isRobot = await this.prompt.confirm('Are you a robot?')\n    const code = await this.prompt.editor('Write a hello world code')\n    const card = await this.prompt.list('Select your card type', [\n      'debit',\n      'credit',\n    ])\n    const roles = await this.prompt.checkbox('Select the roles', [\n      'customer',\n      'admin',\n    ])\n\n    console.log()\n\n    this.logger.success('Information successfully collected:')\n    this.logger\n      .table()\n      .head('Names', 'Password', 'Is Robot?', 'Code', 'Card', 'Roles')\n      .row([name, password, `${isRobot}`, code, card, roles.join(', ')])\n      .render()\n  }\n}\n")),(0,i.kt)(o.Z,{playing:!0,controls:!0,className:"react-player-center",url:"/videos/prompt-example.mp4",mdxType:"ReactPlayer"}),(0,i.kt)("h5",{id:"thispromptinput"},(0,i.kt)("inlineCode",{parentName:"h5"},"this.prompt.input()")),(0,i.kt)("p",null,"Displays the prompt to enter a input value.\nOptionally accepts ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"second argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.input('What is your name?', {\n  validate(input: string) {\n    if (!input || input.length < 2) {\n      return 'Name is required and must be over 2 characters'\n    }\n\n    return true\n  },\n})\n")),(0,i.kt)("h4",{id:"thispromptsecret"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.prompt.secret()")),(0,i.kt)("p",null,"Same as ",(0,i.kt)("inlineCode",{parentName:"p"},"input()")," but hide what the user is typing.\nOptionally accepts\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"second argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.secret('What is your password?', {\n  validate(input: string) {\n    if (!input || input.length < 2) {\n      return 'Password is required and must be over 2 characters'\n    }\n\n    return true\n  },\n})\n")),(0,i.kt)("h4",{id:"thispromptconfirm"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.prompt.confirm()")),(0,i.kt)("p",null,"Display the prompt to select between ",(0,i.kt)("strong",{parentName:"p"},"Yes")," and\n",(0,i.kt)("strong",{parentName:"p"},"No"),". Optionally\naccepts ",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"second argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.confirm('Are you a robot?')\n")),(0,i.kt)("h4",{id:"thisprompteditor"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.prompt.editor()")),(0,i.kt)("p",null,"Open a code editor to write a bigger message,\nusually code. Optionally accepts\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"second argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.editor('Write a hello world code in Python')\n")),(0,i.kt)("h4",{id:"thispromptlist"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.prompt.list()")),(0,i.kt)("p",null,"Display a list of options with the possibility to choose\nonly one. Optionally accepts\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"third argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.list('Select your registry', ['npm', 'pnpm', 'yarn'])\n")),(0,i.kt)("h4",{id:"thispromptcheckbox"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.prompt.checkbox()")),(0,i.kt)("p",null,"Display a list of options with the possibility to choose\nmultiple. Optionally accepts\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/inquirer#question"},"options"),"\nas the ",(0,i.kt)("strong",{parentName:"p"},"third argument"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.prompt.checkbox('Select your dependencies', [\n  '@athenna/core', '@athenna/artisan', '@athenna/http'\n])\n")),(0,i.kt)("h2",{id:"logger-and-ui"},"Logger and UI"),(0,i.kt)("p",null,"You can make use of the inbuilt logger to log messages\nto the console using the ",(0,i.kt)("inlineCode",{parentName:"p"},"this.logger")," property. Artisan\nlogger extends the ",(0,i.kt)("a",{parentName:"p",href:"/docs/the-basics/logging"},(0,i.kt)("inlineCode",{parentName:"a"},"Logger")),"\nclass from ",(0,i.kt)("inlineCode",{parentName:"p"},"@athenna/logger"),", but it also adds some new\nmethods to it: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Exec } from '@athenna/common'\nimport { BaseCommand } from '@athenna/artisan'\n\nexport class Greet extends BaseCommand {\n  public static signature(): string {\n    return 'greet'\n  }\n\n  public async handle() {\n    this.logger.simple('({ green, bold }) Hello ({ yellow, bold, italic }) World!')\n\n    this.logger.update('Hey!!')\n    await Exec.sleep(1000)\n    this.logger.update('How you doing?')\n\n    this.logger.rainbow('Athenna Framework')\n\n    const spinner = this.logger.spinner('Loading unicorns')\n\n    spinner.start()\n\n    setTimeout(() => {\n      spinner.color = 'yellow'\n      spinner.text = 'Loading rainbows'\n    }, 1000)\n\n    await this.logger.promiseSpinner(Exec.sleep(2000), {\n      text: 'Loading',\n      successText: 'Success!',\n      failText: 'Failed!',\n    })\n\n    this.logger\n      .table()\n      .head('HEAD 1', 'HEAD 2')\n      .row(['VALUE 1', 'VALUE 2'])\n      .row(['VALUE 1', 'VALUE 2'])\n      .render()\n\n    const data = {\n      'commander@0.6.1': 1,\n      'minimatch@0.2.14': 3,\n      'mkdirp@0.3.5': 2,\n      'sigmund@1.0.0': 3,\n    }\n\n    this.logger.column(data, { columns: ['MODULE', 'COUNT'] })\n\n    const path = 'app/services/Service.ts'\n    const action = this.logger.action('create')\n\n    action.succeeded(path)\n    action.skipped(path, 'File already exists')\n    action.failed(path, 'Something went wrong')\n\n    this.logger\n      .instruction()\n      .head('Project Created')\n      .add(`cd ${this.paint.cyan('hello-world')}`)\n      .add(`Run ${this.paint.cyan('./node artisan --watch serve')}`)\n      .render()\n\n    this.logger\n      .sticker()\n      .head('Athenna Framework')\n      .add('Follow us on Instagram: @athenna.io \ud83c\udf77')\n      .render()\n\n    await this.logger\n      .task()\n      .add('First task', async task => {\n        await Exec.sleep(1000)\n        await task.complete('Completed!')\n      })\n      .add('Second task', async task => {\n        await Exec.sleep(1000)\n        await task.fail('Failed!')\n      })\n      .run()\n  }\n}\n")),(0,i.kt)(o.Z,{playing:!0,controls:!0,className:"react-player-center",url:"/videos/loggerui-example.mp4",mdxType:"ReactPlayer"}),(0,i.kt)("h4",{id:"thisloggersimple"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.simple()")),(0,i.kt)("p",null,"Works like ",(0,i.kt)("inlineCode",{parentName:"p"},"console.log()"),", but automatically handles\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/the-basics/helpers#colorapply"},"color engine"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.logger.simple('({ green, bold }) Hello ({ yellow, bold, italic }) World!')\n")),(0,i.kt)("h4",{id:"thisloggerupdate"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.update()")),(0,i.kt)("p",null,"Works like ",(0,i.kt)("a",{parentName:"p",href:"/docs/cli-application/commands#thisloggersimple"},(0,i.kt)("inlineCode",{parentName:"a"},"this.logger.simple()")),",\nbut if you call the method multiple times,\nit will always update the message instead\nof printing a new one:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Exec } from '@athenna/common' \n\nthis.logger.update('Hey!!')\n\nawait Exec.sleep(1000)\n\nthis.logger.update('How you doing?')\n")),(0,i.kt)("h4",{id:"thisloggerrainbow"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.rainbow()")),(0,i.kt)("p",null,"Print a message with all the colors of the\nrainbow and with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lukesampson/figlet/blob/master/figfont.txt"},"FIGfont"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.logger.rainbow('Hello World!')\n")),(0,i.kt)("h4",{id:"thisloggerspinner"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.spinner()")),(0,i.kt)("p",null,"Creates a spinner to show a loading message.\nVery useful when running something in background\nand you want to give some feedback for your user:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const spinner = this.logger.spinner('Loading unicorns')\n\nspinner.start()\n\nsetTimeout(() => {\n  spinner.color = 'yellow'\n  spinner.text = 'Loading rainbows'\n}, 1000)\n")),(0,i.kt)("h4",{id:"thisloggerpromisespinner"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.promiseSpinner()")),(0,i.kt)("p",null,"Creates a spinner from a promise. If the promisse\nresolves show the ",(0,i.kt)("inlineCode",{parentName:"p"},"successText"),", if fails, the ",(0,i.kt)("inlineCode",{parentName:"p"},"failText"),",\nkeep running the spinner until the task is running:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Exec } from '@athenna/common'\n\nawait this.logger.promiseSpinner(Exec.sleep(2000), {\n  text: 'Loading',\n  successText: 'Success!',\n  failText: 'Failed!',\n})\n")),(0,i.kt)("h4",{id:"thisloggertable"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.table()")),(0,i.kt)("p",null,"Create text-based table suitable for console\noutput. To render the table you need to call\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"render()")," method at the end:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const table = this.logger.table()\n\nthis.logger.head('HEAD 1', 'HEAD 2')\n\nthis.logger.row(['VALUE 1', 'VALUE 2'])\nthis.logger.row(['VALUE 1', 'VALUE 2'])\n\nthis.logger.render()\n")),(0,i.kt)("h4",{id:"thisloggercolumn"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.column()")),(0,i.kt)("p",null,"Create text-based columns suitable for\nconsole output from objects or arrays\nof objects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const data = {\n  'commander@0.6.1': 1,\n  'minimatch@0.2.14': 3,\n  'mkdirp@0.3.5': 2,\n  'sigmund@1.0.0': 3,\n}\n\nthis.logger.column(data, { columns: ['MODULE', 'COUNT'] })\n")),(0,i.kt)("h4",{id:"thisloggeraction"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.action()")),(0,i.kt)("p",null,"Log an action that is happening. Actions has three states\n",(0,i.kt)("strong",{parentName:"p"},"succeeded"),", ",(0,i.kt)("strong",{parentName:"p"},"skipped")," and ",(0,i.kt)("strong",{parentName:"p"},"failed"),". You can use\nactions to explain to the user what happened to some\ndetermined operation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const path = 'app/services/Service.ts'\nconst action = this.logger.action('create')\n\naction.succeeded(path)\naction.skipped(path, 'File already exists')\naction.failed(path, 'Something went wrong')\n")),(0,i.kt)("h4",{id:"thisloggerinstruction"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.instruction()")),(0,i.kt)("p",null,"Use to display instructions for a given action\nby rendering them inside a box:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const instruction = this.logger.instruction()\n\ninstruction.head('Project Created')\n\ninstruction.add(`cd ${this.paint.cyan('hello-world')}`)\ninstruction.add(`Run ${this.paint.cyan('./node artisan --watch serve')}`)\n  \ninstruction.render()\n")),(0,i.kt)("h4",{id:"thisloggersticker"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.sticker()")),(0,i.kt)("p",null,"Use to display stickers for a given\naction by rendering them inside a box.\nStickers have the same API of\n",(0,i.kt)("a",{parentName:"p",href:"/docs/cli-application/commands#thisloggerinstructions"},(0,i.kt)("inlineCode",{parentName:"a"},"this.logger.instructions()")),",\nbut the rows will not have the icon in front:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const sticker = this.logger.sticker()\n\nsticker.head('Athenna Framework')\nsticket.add('Follow us on Instagram: @athenna.io \ud83c\udf77')\n\nsticker.render()\n")),(0,i.kt)("h4",{id:"thisloggertask"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.logger.task()")),(0,i.kt)("p",null,"Create a task runner that will log the\nstatus of each task. The task\nmethod is very useful when you need to\ndo a lot of tasks in order, giving a status\nto all the tasks and how much time it has\ntaken to execute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Exec } from '@athenna/common'\n\nconst task = this.logger.task()\n\ntask.add('First task', async task => {\n  await Exec.sleep(1000)\n  await task.complete('Completed!')\n})\n\ntask.add('Second task', async task => {\n  await Exec.sleep(1000)\n  await task.fail('Failed!')\n})\n\nawait task.run()\n")),(0,i.kt)("h2",{id:"generating-templates-in-commands"},"Generating templates in commands"),(0,i.kt)("p",null,"Artisan has support to generate files from templates.\nLet's create a command that generate repositories. First\nof all we need to create our template file and give it a name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=\"Path.resources('templates/repository.edge')\"",title:"\"Path.resources('templates/repository.edge')\""},"export class {{ namePascal }} {\n}\n")),(0,i.kt)("p",null,"Now we map our new template in ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title=".athennarc.json"',title:'".athennarc.json"'},'{\n  "templates": {\n    ...\n    "repository": "./resources/templates/repository.edge"\n    ...\n  }\n}\n')),(0,i.kt)("p",null,"And now we can run\n",(0,i.kt)("inlineCode",{parentName:"p"},"./node artisan make:command MakeRepositoryCommand"),"\nto create our command that will be responsible\nto create our repositories:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=\"Path.commands('MakeRepositoryCommand.ts')\"",title:"\"Path.commands('MakeRepositoryCommand.ts')\""},"import { Path, String } from '@athenna/common'\nimport { sep, resolve, isAbsolute } from 'node:path'\nimport { BaseCommand, Argument } from '@athenna/artisan'\n\nexport class MakeRepositoryCommand extends BaseCommand {\n  @Argument({\n    description: 'The repository name.',\n  })\n  public name: string\n\n  public static signature(): string {\n    return 'make:repository'\n  }\n\n  public static description(): string {\n    return 'Make a new repository file.'\n  }\n\n  public async handle() {\n    this.logger.simple('({bold,green} [ MAKING REPOSITORY ])\\n')\n\n    const file = await this.generator\n      .path(this.getFilePath())\n      .template('repository') // \ud83d\udc48 Our template name\n      .setNameProperties(true)\n      .make()\n\n    this.logger.success(\n      `Repository ({yellow} \"${file.name}\") successfully created.`,\n    )\n  }\n\n  private getFilePath(): string {\n    return this.getDestinationPath().concat(`${sep}${this.name}.${Path.ext()}`)\n  }\n\n  private getDestinationPath(): string {\n    let destination = Config.get(\n      'rc.commands.make:repository.destination',\n      Path.repositories(),\n    )\n\n    if (!isAbsolute(destination)) {\n      destination = resolve(Path.pwd(), destination)\n    }\n\n    return destination\n  }\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The example above is a little bit complex. But\nthat is exactly what we do internally with other\n",(0,i.kt)("inlineCode",{parentName:"p"},"make:...")," commands.")),(0,i.kt)("h4",{id:"thisgeneratorpath"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.generator.path()")),(0,i.kt)("p",null,"Set the file path where the file will be generated.\nRememeber that the file name in the path will be used\nto define the name properties:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.generator.path(Path.repositories('UserRepository.ts'))\n")),(0,i.kt)("h4",{id:"thisgeneratortemplate"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.generator.template()")),(0,i.kt)("p",null,"Set the template name to be resolved by\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"@athenna/view")," package that will read\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"templates")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json"),"\nto find the path to your template file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.generator.path('repository')\n")),(0,i.kt)("h4",{id:"thisgeneratorproperties"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.generator.properties()")),(0,i.kt)("p",null,"Set custom properties names to be replaceble inside\nthe template, check the example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"console.log('Hello {{ name }}')\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.generator.properties({ name: 'Lenon' })\n")),(0,i.kt)("h4",{id:"thisgeneratorsetnameproperties"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.generator.setNameProperties()")),(0,i.kt)("p",null,"Define custom properties in different cases\nfrom the file name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.generator.setNameProperties(true)\n")),(0,i.kt)("p",null,"If you set this to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the following properties\nwill be available to be replaced in your template:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n  nameUp: 'MYREPOSITORY',\n  nameCamel: 'myRepository',\n  namePlural: 'MyRepositories',\n  namePascal: 'MyRepository',\n  namePluralCamel: 'myRepositories',\n  namePluralPascal: 'MyRepositories',\n  nameUpTimestamp: 'MYREPOSITORY1675363499530',\n  nameCamelTimestamp: 'myRepository1675363499530',\n  namePluralTimestamp: 'MyRepositories1675363499530',\n  namePascalTimestamp: 'MyRepository1675363499530',\n  namePluralCamelTimestamp: 'myRepositories1675363499530',\n  namePluralPascalTimestamp: 'MyRepositories1675363499530',\n   ...properties, // <- Custom properties set with `this.generator.properties()` method.\n}\n")),(0,i.kt)("h4",{id:"thisgeneratormake"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.generator.make()")),(0,i.kt)("p",null,"Finally, generate the file and return it\nas an instance of ",(0,i.kt)("a",{parentName:"p",href:"/docs/the-basics/helpers#file"},(0,i.kt)("inlineCode",{parentName:"a"},"File")),".\nThis method needs to always be called at the end to generate\nthe file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const file = await this.generator.make()\n")),(0,i.kt)("h2",{id:"manipulating-athennarcjson-in-commands"},"Manipulating ",(0,i.kt)("inlineCode",{parentName:"h2"},".athennarc.json")," in commands"),(0,i.kt)("p",null,"You can manipulate the ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file in your\ncommands logic using the ",(0,i.kt)("inlineCode",{parentName:"p"},"this.rc")," property. Let's suppose\nthat in ",(0,i.kt)("inlineCode",{parentName:"p"},"MakeRepositoryCommand")," we would like to register\nthe repositories as a ",(0,i.kt)("strong",{parentName:"p"},"service"),", we could do the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Path, String } from '@athenna/common'\nimport { sep, resolve, isAbsolute } from 'node:path'\nimport { BaseCommand, Argument } from '@athenna/artisan'\n\nexport class MakeRepositoryCommand extends BaseCommand {\n  @Argument({\n    description: 'The repository name.',\n  })\n  public name: string\n\n  public static signature(): string {\n    return 'make:repository'\n  }\n\n  public static description(): string {\n    return 'Make a new repository file.'\n  }\n\n  public async handle() {\n    this.logger.simple('({bold,green} [ MAKING REPOSITORY ])\\n')\n\n    const file = await this.generator\n      .path(this.getFilePath())\n      .template('repository')\n      .setNameProperties(true)\n      .make()\n\n    this.logger.success(\n      `Repository ({yellow} \"${file.name}\") successfully created.`,\n    )\n\n    const importPath = this.getImportPath(file.name)\n\n    await this.rc.pushTo('services', importPath).save() // \ud83d\udc48\n\n    this.logger.success(\n      `Athenna RC updated: ({dim,yellow} { services += \"${signature}\": \"${importPath}\" })`,\n    )\n  }\n\n  private getFilePath(): string {\n    return this.getDestinationPath().concat(`${sep}${this.name}.${Path.ext()}`)\n  }\n\n  private getDestinationPath(): string {\n    let destination = Config.get(\n      'rc.commands.make:repository.destination',\n      Path.repositories(),\n    )\n\n    if (!isAbsolute(destination)) {\n      destination = resolve(Path.pwd(), destination)\n    }\n\n    return destination\n  }\n\n  private getImportPath(fileName: string): string {\n    const destination = this.getDestinationPath()\n\n    return `${destination\n      .replace(Path.pwd(), '')\n      .replace(/\\\\/g, '/')\n      .replace('/', '#')}/${fileName}`\n  }\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Again, the example above is a little bit complex. But\nthat is exactly what we do internally with other\n",(0,i.kt)("inlineCode",{parentName:"p"},"make:...")," commands where we need to register something\nin the ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json")," file.")),(0,i.kt)("h4",{id:"thisrcfile"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.file")),(0,i.kt)("p",null,"Manipulate the ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json"),"\n",(0,i.kt)("a",{parentName:"p",href:"/docs/the-basics/helpers#file"},(0,i.kt)("inlineCode",{parentName:"a"},"File"))," instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"Log.info(this.rc.file.name)\n")),(0,i.kt)("h4",{id:"thisrccontent"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.content")),(0,i.kt)("p",null,"Manipulate the content of ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json")," as an\n",(0,i.kt)("a",{parentName:"p",href:"/docs/the-basics/helpers#object-builder"},(0,i.kt)("inlineCode",{parentName:"a"},"ObjectBuilder")),"\ninstance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.rc.content.has('commands') // true\n")),(0,i.kt)("h4",{id:"thisrcsetfile"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.setFile()")),(0,i.kt)("p",null,"Specify which file should be manipulated. By default\nit will always be the ",(0,i.kt)("inlineCode",{parentName:"p"},".athennarc.json"),", if the file doesn't\nexist, the ",(0,i.kt)("inlineCode",{parentName:"p"},"athenna")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},"package.json")," will be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"this.rc.setFile(Path.pwd('.athennarc.prod.json'))\n")),(0,i.kt)("h4",{id:"thisrcsetto"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.setTo()")),(0,i.kt)("p",null,"Set or subscibre a ",(0,i.kt)("strong",{parentName:"p"},"KEY:VALUE")," property in some property\nof the RC configuration file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const rcKey = 'commands'\nconst key = 'make:repository'\nconst value = '#app/console/commands/UserRepository'\n\nthis.rc.setTo(rcKey, key, value)\n")),(0,i.kt)("p",null,"You can also pass any value as a second parameter to set\nmultiple properties at once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const rcKey = 'commands'\n\nthis.rc.setTo(rcKey, {\n  'make:repository': '#app/console/commands/UserRepository'\n})\n")),(0,i.kt)("h4",{id:"thisrcpushto"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.pushTo()")),(0,i.kt)("p",null,"Push a new value to some array property of the RC file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const rcKey = 'services'\n\nthis.rc.pushTo(rcKey, '#app/repositories/MyRepository')\n")),(0,i.kt)("h4",{id:"thisrcsave"},(0,i.kt)("inlineCode",{parentName:"h4"},"this.rc.save()")),(0,i.kt)("p",null,"Finally, save all the change made to the RC file.\nThis method needs to always be called at the end:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"await this.rc.save()\n")),(0,i.kt)("h2",{id:"executing-commands-programmatically"},"Executing commands programmatically"),(0,i.kt)("p",null,"Sometimes you may wish to call other commands from an\nexisting Artisan command or from any other part of your\napplication. You may do so using the ",(0,i.kt)("inlineCode",{parentName:"p"},"call()")," method from\nArtisan. This method accepts the command string with its\narguments and options:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Artisan } from '@athenna/artisan'\n\nawait Artisan.call('make:controller TestController')\n")),(0,i.kt)("p",null,"If you want to verify if your command has generated some\noutput in ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"stderr")," you can use the\n",(0,i.kt)("inlineCode",{parentName:"p"},"callInChild()")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const { stdout, stderr } = await Artisan.callInChild('make:controller TestController')\n\nassert.isTrue(stdout.includes('[ MAKING CONTROLLER ]'))\nassert.isUndefined(stderr)\n")),(0,i.kt)("p",null,"By default this method will look to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Path.boostrap('artisan.ts')"),"\nfile to execute your command, but you can change the file to be used\nsetting the path to it as second parameter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const command = 'make:controller TestController'\nconst artisanPath = Path.pwd(`artisan.${Path.ext()}`)\n\nawait Artisan.callInChild(command, artisanPath)\n")))}u.isMDXComponent=!0}}]);