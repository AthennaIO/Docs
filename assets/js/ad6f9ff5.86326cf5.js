"use strict";(self.webpackChunk_athenna_docs=self.webpackChunk_athenna_docs||[]).push([[2106],{3317:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"orm/relationships","title":"Relationships","description":"See how to create relations between models in Athenna Framework.","source":"@site/docs/orm/relationships.mdx","sourceDirName":"orm","slug":"/orm/relationships","permalink":"/docs/orm/relationships","draft":false,"unlisted":false,"editUrl":"https://github.com/AthennaIO/Docs/tree/main/docs/orm/relationships.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Relationships","sidebar_position":3,"description":"See how to create relations between models in Athenna Framework."},"sidebar":"tutorialSidebar","previous":{"title":"Query Builder","permalink":"/docs/orm/query-builder"},"next":{"title":"Extending Models","permalink":"/docs/orm/extending-models"}}');var t=o(4848),i=o(8453);const r={title:"Relationships",sidebar_position:3,description:"See how to create relations between models in Athenna Framework."},a="ORM: Relationships",l={},d=[{value:"Defining relationships",id:"defining-relationships",level:2},{value:"One To One",id:"one-to-one",level:2},{value:"Defining the inverse of the relationship",id:"defining-the-inverse-of-the-relationship",level:3},{value:"One To Many",id:"one-to-many",level:2},{value:"Defining the inverse of the relationship (Many To One)",id:"defining-the-inverse-of-the-relationship-many-to-one",level:3},{value:"Many To Many",id:"many-to-many",level:2},{value:"Table structure",id:"table-structure",level:3},{value:"Model structure",id:"model-structure",level:3},{value:"Defining the inverse of the relationship",id:"defining-the-inverse-of-the-relationship-1",level:3},{value:"Retrieving pivot table data",id:"retrieving-pivot-table-data",level:3},{value:"Eager loading",id:"eager-loading",level:2},{value:"Eager loading multiple relationships",id:"eager-loading-multiple-relationships",level:3},{value:"Nested eager loading",id:"nested-eager-loading",level:3},{value:"Constraining eager loads",id:"constraining-eager-loads",level:3},{value:"Relationship&#39;s relationships constraints",id:"relationships-relationships-constraints",level:4},{value:"Inserting &amp; updating related models",id:"inserting--updating-related-models",level:2},{value:"Creating many-to-many relationships",id:"creating-many-to-many-relationships",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"orm-relationships",children:"ORM: Relationships"})}),"\n",(0,t.jsx)(n.p,{children:"See how to create relations between models in Athenna Framework."}),"\n",(0,t.jsx)(n.h2,{id:"defining-relationships",children:"Defining relationships"}),"\n",(0,t.jsx)(n.p,{children:"Database tables are often related to one another. For example, a\nblog post may have many comments or an order could be related to\nthe user who placed it. Athenna makes managing and working with\nthese relationships easy, and supports a variety of common\nrelationships that are defined as properties on your model classes\nusing annotations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import {\n  Column,\n  HasOne,\n  HasMany,\n  BaseModel,\n  BelongsTo,\n  BelongsToMany,\n  type Relation,\n} from '@athenna/database'\n\nimport { Course } from '#src/models/Course'\nimport { Profile } from '#src/models/Profile'\nimport { Comment } from '#src/models/Comment'\nimport { Customer } from '#src/models/Customer'\nimport { UsersCourses } from '#src/models/UsersCourses'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number \n\n  @HasOne(() => Profile)\n  public profile: Relation<Profile> \n\n  @HasMany(() => Comment)\n  public comments: Relation<Comment[]> \n\n  @BelongsTo(() => Customer)\n  public customer: Relation<Customer> \n\n  @BelongsToMany(() => Course, () => UsersCourses) \n  public courses: Relation<Course[]> \n}\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"Check the full documentation of relationships annotations:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/annotations#has-one",children:(0,t.jsx)(n.code,{children:"@HasOne()"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/annotations#has-many",children:(0,t.jsx)(n.code,{children:"@HasMany()"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/annotations#belongs-to",children:(0,t.jsx)(n.code,{children:"@BelongsTo()"})})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/annotations#belongs-to-many",children:(0,t.jsx)(n.code,{children:"@BelongsToMany()"})})}),"\n"]})]}),"\n",(0,t.jsx)(n.p,{children:"On this documentation you will see how to setup the following\nrelationships using the above annotations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/relationships#one-to-one",children:"One To One"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/relationships#one-to-many",children:"One To Many"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/orm/relationships#many-to-many",children:"Many To Many"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"one-to-one",children:"One To One"}),"\n",(0,t.jsxs)(n.p,{children:["A one-to-one relationship is a very basic type of database relationship.\nFor example, a ",(0,t.jsx)(n.code,{children:"User"})," model might be associated with one ",(0,t.jsx)(n.code,{children:"Phone"})," model.\nTo define this relationship, we will place a ",(0,t.jsx)(n.code,{children:"phone"})," property on the ",(0,t.jsx)(n.code,{children:"User"}),"\nmodel and annotate it with the ",(0,t.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Phone } from '#src/models/Phone'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, HasOne, type Relation } from '@athenna/database'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number\n\n  @HasOne(() => Phone)\n  public phone: Relation<Phone> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The first argument passed to the ",(0,t.jsx)(n.code,{children:"@HasOne()"})," annotation is closure\nthat return the related model class. Once the relationship is defined,\nwe may retrieve the related record using the ",(0,t.jsx)(n.code,{children:"with()"})," method of the\nmodel query builder:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { phone } = await User.query()\n  .with('phone')\n  .find()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since all relationships are extending ",(0,t.jsx)(n.code,{children:"BaseModel"}),", you may add further\nconstraints to the relationship query by adding a closure as second argument\nof the ",(0,t.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { phone } = await User.query()\n  .with('phone')\n  .find()\n\n// Or\n\nconst user = await User.find()\n\nawait user.load('phone', query => query.where('ddd', '+55'))\n\nconsole.log(user.phone)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Athenna determines the foreign key of the relationship based on the\nparent model name. In this case, the ",(0,t.jsx)(n.code,{children:"Phone"})," model is automatically\nassumed to have a ",(0,t.jsx)(n.code,{children:"userId"})," foreign key. If you wish to override this\nconvention, you may pass a second argument to the ",(0,t.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@HasOne(() => Phone, { foreignKey: 'foreignKey' })\npublic phone: Relation<Phone> \n"})}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, Athenna assumes that the foreign key should have a\nvalue matching the primary key column of the parent. In other words,\nAthenna will look for the value of the user's id column in the ",(0,t.jsx)(n.code,{children:"userId"}),"\ncolumn of the ",(0,t.jsx)(n.code,{children:"Phone"})," record. If you would like the relationship to\nuse a primary key value other than ",(0,t.jsx)(n.code,{children:"id"}),", you may pass a ",(0,t.jsx)(n.code,{children:"primaryKey"}),"\nproperty to the options in the second argument:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@HasOne(() => Phone, {\n  primaryKey: 'primaryKey',\n  foreignKey: 'foreignKey'\n})\npublic phone: Relation<Phone> \n"})}),"\n",(0,t.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship",children:"Defining the inverse of the relationship"}),"\n",(0,t.jsxs)(n.p,{children:["So, we can access the ",(0,t.jsx)(n.code,{children:"Phone"})," model from our ",(0,t.jsx)(n.code,{children:"User"})," model.\nNext, let's define a relationship on the ",(0,t.jsx)(n.code,{children:"Phone"})," model that\nwill let us access the user that owns the phone. We can define\nthe inverse of a ",(0,t.jsx)(n.code,{children:"@HasOne()"})," relationship using the ",(0,t.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { User } from '#src/models/User'\nimport type { Relation } from '@athenna/database'\nimport { Column, BelongsTo, BaseModel } from '@athenna/database'\n\nexport class Phone extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public userId: number\n\n  @BelongsTo(() => User)\n  public user: Relation<User> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When invoking the ",(0,t.jsx)(n.code,{children:"with('user')"})," method, Athenna will attempt to find\na ",(0,t.jsx)(n.code,{children:"User"})," model that has an id which matches the ",(0,t.jsx)(n.code,{children:"userId"})," column on the\n",(0,t.jsx)(n.code,{children:"Phone"})," model."]}),"\n",(0,t.jsxs)(n.p,{children:["Athenna determines the foreign key name by examining the name of the\nrelationship model and suffixing it with ",(0,t.jsx)(n.code,{children:"Id"}),". So, in this case,\nAthenna assume that the ",(0,t.jsx)(n.code,{children:"Phone"})," model has a ",(0,t.jsx)(n.code,{children:"userId"})," column. However,\nif the foreign key on the ",(0,t.jsx)(n.code,{children:"Phone"})," model is not ",(0,t.jsx)(n.code,{children:"userId"}),", you may pass\na custom key name as the second argument to the ",(0,t.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => User, { foreignKey: 'foreignKey' })\npublic user: Relation<User> \n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the parent model does not use ",(0,t.jsx)(n.code,{children:"id"})," as its primary key, or you wish\nto find the associated model using a different column, you may pass a\nthird argument to the ",(0,t.jsx)(n.code,{children:"@BelongsTo()"})," method specifying the parent\ntable's custom key:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => User, { \n  primaryKey: 'primaryKey',\n  foreignKey: 'foreignKey' \n})\npublic user: Relation<User> \n"})}),"\n",(0,t.jsx)(n.h2,{id:"one-to-many",children:"One To Many"}),"\n",(0,t.jsxs)(n.p,{children:["A one-to-many relationship is used to define relationships where a\nsingle model is the parent to one or more child models. For example,\na blog post may have an infinite number of comments. Like all other\nAthenna relationships, one-to-many relationships are defined by\ndefining a ",(0,t.jsx)(n.code,{children:"@HasMany()"})," annotation in your model class property:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Comment } from '#src/models/Comment'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, HasMany } from '@athenna/database'\n\nexport class Post extends BaseModel {\n  @Column()\n  public id: number\n\n  @HasMany(() => Comment)\n  public comments: Relation<Comment[]> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Remember, Athenna will automatically determine the proper foreign\nkey column for the ",(0,t.jsx)(n.code,{children:"Comment"}),' model. By convention, Athenna will take\nthe "camelCase" name of the parent model and suffix it with ',(0,t.jsx)(n.code,{children:"Id"}),". So,\nin this example, Athenna will assume the foreign key column on the\n",(0,t.jsx)(n.code,{children:"Comment"})," model is ",(0,t.jsx)(n.code,{children:"postId"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Once the relationship method has been defined, we can access the\ndata of related ",(0,t.jsx)(n.code,{children:"comments"})," by using the ",(0,t.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { comments } = await Post.query()\n  .with('comments')\n  .find()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since all relationships are extending ",(0,t.jsx)(n.code,{children:"BaseModel"}),", you may add further\nconstraints to the relationship query by adding a closure as second argument\nof the ",(0,t.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { comments } = await Post.query()\n  .with('comments', query => query.where('title', 'foo'))\n  .find()\n\n// Or\n\nconst post = await Post.find()\n\nawait post.load('comments', query => query.where('title', 'foo'))\n\nconsole.log(post.comments)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Like the ",(0,t.jsx)(n.code,{children:"@HasOne()"})," annotation, you may also override the foreign and\nprimary keys by passing the additional options second argument to the\n",(0,t.jsx)(n.code,{children:"@HasOne()"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@HasMany(() => Comment, { \n  foreignKey: 'foreignKey',\n  primaryKey: 'primaryKey'\n})\npublic comments: Relation<Comment[]>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship-many-to-one",children:"Defining the inverse of the relationship (Many To One)"}),"\n",(0,t.jsxs)(n.p,{children:["Now that we can access all of a post's comments, let's define a\nrelationship to allow a comment to access its parent post. To\ndefine the inverse of a ",(0,t.jsx)(n.code,{children:"@HasMany()"})," relationship, define a\nrelationship property on the child model annotated with the\n",(0,t.jsx)(n.code,{children:"@BelongsTo()"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Post } from '#src/models/Post'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, BelongsTo } from '@athenna/database'\n\nexport class Comment extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public postId: number\n\n  @BelongsTo(() => Post)\n  public post: Relation<Post> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And just like the other relationships, once we have defined it in\nour class, we can retrieve a comment's parent post by using the\n",(0,t.jsx)(n.code,{children:"with()"})," and ",(0,t.jsx)(n.code,{children:"load()"})," methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { post } = await Comment.query()\n  .with('post', query => query.where('title', 'foo'))\n  .find()\n\n// Or\n\nconst comment = await Comment.find()\n\nawait comment.load('post', query => query.where('title', 'foo'))\n\nconsole.log(comment.post)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, Athenna will attempt to find a Post model\nthat has an id which matches the ",(0,t.jsx)(n.code,{children:"postId"})," column on the Comment model."]}),"\n",(0,t.jsxs)(n.p,{children:["Athenna determines the foreign key name by examining the name of the\nrelationship model and suffixing it with ",(0,t.jsx)(n.code,{children:"Id"}),". So, in this case,\nAthenna assume that the ",(0,t.jsx)(n.code,{children:"Comment"})," model has a ",(0,t.jsx)(n.code,{children:"postId"})," column. However,\nif the foreign key on the ",(0,t.jsx)(n.code,{children:"Comment"})," model is not ",(0,t.jsx)(n.code,{children:"postId"}),", you may pass\na custom key name as the second argument to the ",(0,t.jsx)(n.code,{children:"@BelongsTo()"}),"\nannotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => Post, { foreignKey: 'foreignKey' })\npublic post: Relation<Post[]>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If your parent model does not use ",(0,t.jsx)(n.code,{children:"id"})," as its primary key, or you\nwish to find the associated model using a different column, you\nmay pass a ",(0,t.jsx)(n.code,{children:"primaryKey"})," option specifying your parent table's\ncustom key:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsTo(() => Post, {\n  foreignKey: 'foreignKey',\n  primaryKey: 'primaryKey'\n})\npublic post: Relation<Post[]>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"many-to-many",children:"Many To Many"}),"\n",(0,t.jsx)(n.p,{children:'Many-to-many relations are slightly more complicated than one-to-one\nand one-to-many relationships. An example of a many-to-many relationship\nis a user that has many roles and those roles are also shared by other\nusers in the application. For example, a user may be assigned the role\nof "Author" and "Editor"; however, those roles may also be assigned to\nother users as well. So, a user has many roles and a role has many users.'}),"\n",(0,t.jsx)(n.h3,{id:"table-structure",children:"Table structure"}),"\n",(0,t.jsxs)(n.p,{children:["To define this relationship, three database tables are needed: ",(0,t.jsx)(n.code,{children:"users"}),",\n",(0,t.jsx)(n.code,{children:"roles"}),", and ",(0,t.jsx)(n.code,{children:"roles_users"}),". The ",(0,t.jsx)(n.code,{children:"roles_users"})," table is derived from the\nalphabetical order of the related model names and contains ",(0,t.jsx)(n.code,{children:"userId"}),"\nand ",(0,t.jsx)(n.code,{children:"roleId"})," columns. This table is used as an intermediate table\nlinking the users and roles."]}),"\n",(0,t.jsxs)(n.p,{children:["Remember, since a role can belong to many users, we cannot simply\nplace a ",(0,t.jsx)(n.code,{children:"userId"})," column on the ",(0,t.jsx)(n.code,{children:"roles"})," table. This would mean that a\nrole could only belong to a single user. In order to provide support\nfor roles being assigned to multiple users, the ",(0,t.jsx)(n.code,{children:"roles_users"})," table\nis needed. We can summarize the relationship's table structure like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"users\n    id - integer\n    name - string\n \nroles\n    id - integer\n    name - string\n \nroles_users\n    userId - integer\n    roleId - integer\n"})}),"\n",(0,t.jsx)(n.h3,{id:"model-structure",children:"Model structure"}),"\n",(0,t.jsxs)(n.p,{children:["Many-to-many relationships are defined by defining a property annotated\nwith the ",(0,t.jsx)(n.code,{children:"@BelongsToMany()"})," annotation. But before we check how to define\nthis annotation, we need to first create our ",(0,t.jsx)(n.code,{children:"RolesUsers"})," pivot model:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Role } from '#src/models/Role'\nimport { User } from '#src/models/User'\nimport type { Relation } from '@athenna/database'\nimport { Column, BaseModel, BelongsTo } from '@athenna/database'\n\nexport class RolesUsers extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public roleId: number\n\n  @Column()\n  public userId: number\n\n  @BelongsTo(() => Role)\n  public role: Relation<Role> \n\n  @BelongsTo(() => User)\n  public user: Relation<User> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And now let's define the roles relation on our ",(0,t.jsx)(n.code,{children:"User"})," model. The first\nargument passed to the annotations is a closure that returns the related\nmodel class and the second argument is a closure that returns the pivot\nmodel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Role } from '#src/models/Role'\nimport type { Relation } from '@athenna/database'\nimport { RolesUsers } from '#src/models/RolesUsers'\nimport { Column, BaseModel, BelongsToMany } from '@athenna/database'\n\nexport class User extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public name: string\n\n  @BelongsToMany(() => Role, () => RolesUsers)\n  public roles: Relation<Role[]> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once the relationship is defined, you may access the user's roles using\nthe ",(0,t.jsx)(n.code,{children:"with()"})," or ",(0,t.jsx)(n.code,{children:"load()"})," methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const user = await User.query()\n  .with('roles', query => query.select('id'))\n  .find()\n\n// Or\n\nconst user = await User.find()\n\nawait user.load('roles', query => query.select('id'))\n\nconsole.log(user.roles)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To determine the table name of the relationship's pivot table,\nAthenna will call the ",(0,t.jsx)(n.code,{children:"table()"})," method of the pivot model. However, you\nare free to override this convention. You may do so by passing a third\nargument to the ",(0,t.jsx)(n.code,{children:"@BelongsToMany()"})," annotation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsToMany(() => Role, () => RolesUsers, {\n  pivotTable: 'roles_users'\n})\npublic roles: Relation<Roles[]>\n"})}),"\n",(0,t.jsx)(n.p,{children:"In addition to customizing the name of the pivot table, you may also\ncustomize the column names of the keys on the table by passing additional\narguments to the options:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@BelongsToMany(() => Role, () => RolesUsers, {\n  pivotTable: 'roles_users',\n  primaryKey: 'id',\n  foreignKey: 'userId',\n  relationPrimaryKey: 'id',\n  relationForeignKey: 'roleId'\n})\npublic roles: Relation<Roles[]>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"defining-the-inverse-of-the-relationship-1",children:"Defining the inverse of the relationship"}),"\n",(0,t.jsxs)(n.p,{children:['To define the "inverse" of a many-to-many relationship, is basically\nthe same process of defining on the parent model. To complete our\nuser / role example, let\'s define the ',(0,t.jsx)(n.code,{children:"users"})," property on the ",(0,t.jsx)(n.code,{children:"Role"}),"\nmodel:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { User } from '#src/models/User'\nimport type { Relation } from '@athenna/database'\nimport { RolesUsers } from '#src/models/RolesUsers'\nimport { Column, BaseModel, BelongsToMany } from '@athenna/database'\n\nexport class Role extends BaseModel {\n  @Column()\n  public id: number\n\n  @Column()\n  public name: string\n\n  @BelongsToMany(() => User, () => RolesUsers)\n  public users: Relation<User[]> \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see, the relationship is defined exactly the same as its ",(0,t.jsx)(n.code,{children:"User"}),"\nmodel counterpart with the exception of referencing the ",(0,t.jsx)(n.code,{children:"User"})," model.\nSince we're reusing the ",(0,t.jsx)(n.code,{children:"@BelongsToMany()"}),' annotation, all of the usual\ntable and key customization options are available when defining the\n"inverse" of many-to-many relationships.']}),"\n",(0,t.jsx)(n.h3,{id:"retrieving-pivot-table-data",children:"Retrieving pivot table data"}),"\n",(0,t.jsx)(n.p,{children:"As you have already learned, working with many-to-many relations requires\nthe presence of a pivot table and it pivot model, meaning that if you need\nto retrieve the data from the pivot table, you can simply use the pivot model:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const user = await User.find()\nconst role = await Role.find()\n\nconst rolesUsers = await RolesUsers.query()\n  .where('userId', user.id)\n  .where('roleId', role.id)\n  .findMany()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"eager-loading",children:"Eager loading"}),"\n",(0,t.jsxs)(n.p,{children:['Eager loading alleviates the "N + 1" query problem. To illustrate the N + 1\nquery problem, consider a ',(0,t.jsx)(n.code,{children:"Book"}),' model that "belongs to" to an ',(0,t.jsx)(n.code,{children:"Author"})," model:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Author } from '#src/models/Author'\nimport type { Relation } from '@athenna/database'\nimport { Column, BelongsTo, BaseModel } from '@athenna/database'\n\nexport class Book extends BaseModel {\n  @Column()\n  public id: number\n\n  @BelongsTo(() => Author)\n  public author: Relation<Author>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now, let's retrieve all books and their authors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.findMany()\n\nfor (const book of books) {\n  await book.load('author')\n\n  console.log(book.author.name)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This loop will execute one query to retrieve all of the books within the\ndatabase table, then another query for each book in order to retrieve the\nbook's author. So, if we have 25 books, the code above would run 26 queries:\none for the original book, and 25 additional queries to retrieve the author\nof each book."}),"\n",(0,t.jsxs)(n.p,{children:["Thankfully, we can use eager loading to reduce this operation to just two\nqueries. When building a query, you may specify which relationships should\nbe eager loaded using the ",(0,t.jsx)(n.code,{children:"with()"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.query()\n  .with('author') \ud83d\udc48\n  .findMany()\n\nfor (const book of books) {\n  console.log(book.author.name)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"For this operation, only two queries will be executed - one query to retrieve\nall of the books and one query to retrieve all of the authors for all of the\nbooks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"select * from books\n \nselect * from authors where id in (1, 2, 3, 4, 5, ...)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"eager-loading-multiple-relationships",children:"Eager loading multiple relationships"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes you may need to eager load several different relationships. To do\nso, just concat multiple ",(0,t.jsx)(n.code,{children:"with()"})," calls:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.query()\n  .with('author') \ud83d\udc48\n  .with('publisher') \ud83d\udc48\n  .findMany()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nested-eager-loading",children:"Nested eager loading"}),"\n",(0,t.jsx)(n.p,{children:"To eager load a relationship's relationships, you may use \"dot\" syntax. For\nexample, let's eager load all of the book's authors and all of the author's\npersonal contacts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.query()\n  .with('author.contacts') \ud83d\udc48\n  .findMany()\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.p,{children:["Closures set as second argument of the ",(0,t.jsx)(n.code,{children:"with()"}),' method will be ignored when using\n"dot" syntax to eager load relationship\'s relationships.']}),(0,t.jsxs)(n.p,{children:["Check the ",(0,t.jsx)(n.a,{href:"/docs/orm/relationships#relationships-relationships-constraints",children:"relationship's relationships constraints documentation section"}),"\nto see how you could have more power under the constraints added to each of your relationships."]})]}),"\n",(0,t.jsx)(n.h3,{id:"constraining-eager-loads",children:"Constraining eager loads"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes you may wish to eager load a relationship but also specify additional\nquery conditions for the eager loading query. You can accomplish this by passing\na closure as second argument to the ",(0,t.jsx)(n.code,{children:"with()"})," function that adds additional\nconstraints to the eager loading query:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const users = await User.query()\n  .with('posts', query => query.whereLike('title', '%code%')) \ud83d\udc48\n  .findMany()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, Athenna will only eager load posts where the post's title\ncolumn contains the word ",(0,t.jsx)(n.code,{children:"code"}),". You may call other query builder methods to\nfurther customize the eager loading operation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const users = await User.query()\n  .with('posts', query => query.orderBy('createdAt', 'desc')) \ud83d\udc48\n  .findMany()\n"})}),"\n",(0,t.jsx)(n.h4,{id:"relationships-relationships-constraints",children:"Relationship's relationships constraints"}),"\n",(0,t.jsxs)(n.p,{children:["When using the ",(0,t.jsx)(n.a,{href:"/docs/orm/relationships#nested-eager-loading",children:'"dot" syntax'})," to eager load\nrelationship's relationships the closure set as second argument will always be ignored:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.query()\n  // \u274c Load `author` and `contacts` of author, \n  // but doesn't query only cellphones contacts.\n  .with('author.contacts', query => query.where('isCellphone', true))\n  .findMany()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To have full power under the constraints that you want to add to your queries you can\ncall ",(0,t.jsx)(n.code,{children:"with()"})," method inside of your closure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const books = await Book.query()\n  .with('author', query => {\n    query\n      .where('name', 'Lenon')\n      .with('contacts', query => {\n        query.where('isCellphone', true)\n      })\n  })\n  .findMany()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"inserting--updating-related-models",children:"Inserting & updating related models"}),"\n",(0,t.jsxs)(n.p,{children:["Since all of your relationships extends the ",(0,t.jsx)(n.code,{children:"BaseModel"}),", you can use methods like\n",(0,t.jsx)(n.code,{children:"save()"})," to create your relationships:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const author = await Author.find()\n\nauthor.book = new Book()\n\nauthor.book.authorId = author.id\n\nawait author.book.save()\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or even to update it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const book = await Book.query()\n  .with('author')\n  .find()\n\nbook.author.name = 'Lenon'\n\nawait book.author.save()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"creating-many-to-many-relationships",children:"Creating many-to-many relationships"}),"\n",(0,t.jsx)(n.p,{children:"When working with many-to-many relationships you need to use the pivot model to\ncreate the relation between the other two models:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { User } from '#src/models/User'\nimport { Role } from '#src/models/Role'\nimport { RolesUsers } from '#src/models/RolesUsers'\n\nconst user = await User.find()\nconst role = await Role.find()\n\nconst rolesUsers = new RolesUsers()\n\nrolesUsers.userId = user.id\nrolesUsers.roleId = role.id\n\nawait rolesUsers.save()\n\n// Or simply\n\nawait RolesUsers.create({ userId: user.id, roleId: role.id })\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>a});var s=o(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);